[
  {
    "id": "f001b52f35e5d57e1b8928ad14dc4ceb212ae5f8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/llama-chat.cpp",
    "kind": "function",
    "name": "len",
    "signature": "llama_chat_builtin_templates(const char ** output, size_t len)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "advance",
      "begin",
      "c_str",
      "first",
      "i",
      "it",
      "len",
      "llama_chat_builtin_templates",
      "llm_chat_templates",
      "min",
      "output",
      "size"
    ],
    "start_line": 826,
    "end_line": 833,
    "text": "int32_t llama_chat_builtin_templates(const char ** output, size_t len) {\n    auto it = LLM_CHAT_TEMPLATES.begin();\n    for (size_t i = 0; i < std::min(len, LLM_CHAT_TEMPLATES.size()); i++) {\n        output[i] = it->first.c_str();\n        std::advance(it, 1);\n    }\n    return (int32_t) LLM_CHAT_TEMPLATES.size();\n}"
  },
  {
    "id": "4ebb31f4779524694dfd0177c82d5e75c0830b5d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/llama-chat.cpp",
    "kind": "function",
    "name": "add_ass",
    "signature": "llm_chat_apply_template(\n    llm_chat_template tmpl,\n    const std::vector<const llama_chat_message *> & chat,\n    std::string & dest, bool add_ass)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "add_ass",
      "add_bos_inside_history",
      "begin",
      "bos",
      "chat",
      "content",
      "dest",
      "empty",
      "end",
      "front",
      "has_system",
      "i",
      "is_inside_turn",
      "leading_space",
      "llama_chat_message",
      "llm_chat_apply_template",
      "llm_chat_template",
      "llm_chat_template_bailing",
      "llm_chat_template_bailing2",
      "llm_chat_template_bailing_think",
      "llm_chat_template_chatglm_3",
      "llm_chat_template_chatglm_4",
      "llm_chat_template_chatml",
      "llm_chat_template_command_r",
      "llm_chat_template_deepseek",
      "llm_chat_template_deepseek_2",
      "llm_chat_template_deepseek_3",
      "llm_chat_template_dots1",
      "llm_chat_template_exaone_3",
      "llm_chat_template_exaone_4",
      "llm_chat_template_falcon_3",
      "llm_chat_template_gemma",
      "llm_chat_template_gigachat",
      "llm_chat_template_glmedge",
      "llm_chat_template_granite",
      "llm_chat_template_grok_2",
      "llm_chat_template_hunyuan_dense",
      "llm_chat_template_hunyuan_moe",
      "llm_chat_template_kimi_k2",
      "llm_chat_template_llama4",
      "llm_chat_template_llama_2",
      "llm_chat_template_llama_2_sys",
      "llm_chat_template_llama_2_sys_bos",
      "llm_chat_template_llama_2_sys_strip",
      "llm_chat_template_llama_3",
      "llm_chat_template_megrez",
      "llm_chat_template_minicpm",
      "llm_chat_template_mistral_v1",
      "llm_chat_template_mistral_v3",
      "llm_chat_template_mistral_v3_tekken",
      "llm_chat_template_mistral_v7",
      "llm_chat_template_mistral_v7_tekken",
      "llm_chat_template_monarch",
      "llm_chat_template_openai_moe",
      "llm_chat_template_openchat",
      "llm_chat_template_orion",
      "llm_chat_template_phi_3",
      "llm_chat_template_phi_4",
      "llm_chat_template_rwkv_world",
      "llm_chat_template_seed_oss",
      "llm_chat_template_smolvlm",
      "llm_chat_template_vicuna",
      "llm_chat_template_vicuna_orca",
      "llm_chat_template_yandex",
      "llm_chat_template_zephyr",
      "lu8",
      "message",
      "role",
      "size",
      "ss",
      "str",
      "string",
      "stringstream",
      "strip_message",
      "support_system_message",
      "system_prompt",
      "tmpl",
      "toupper",
      "trailing_space",
      "transform",
      "trim",
      "trim_assistant_message",
      "vector"
    ],
    "start_line": 222,
    "end_line": 822,
    "text": "int32_t llm_chat_apply_template(\n    llm_chat_template tmpl,\n    const std::vector<const llama_chat_message *> & chat,\n    std::string & dest, bool add_ass) {\n    // Taken from the research: https://github.com/ggerganov/llama.cpp/issues/5527\n    std::stringstream ss;\n    if (tmpl == LLM_CHAT_TEMPLATE_CHATML) {\n        // chatml template\n        for (auto message : chat) {\n            ss << \"<|im_start|>\" << message->role << \"\\n\" << message->content << \"<|im_end|>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|im_start|>assistant\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7 || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7_TEKKEN) {\n        // Official mistral 'v7' template\n        // See: https://huggingface.co/mistralai/Mistral-Large-Instruct-2411#basic-instruct-template-v7\n        //      https://huggingface.co/mistralai/Mistral-Small-3.1-24B-Instruct-2503#basic-instruct-template-v7-tekken\n        const char * trailing_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7 ? \" \" : \"\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            std::string content(message->content);\n            if (role == \"system\") {\n                ss << \"[SYSTEM_PROMPT]\" << trailing_space << content << \"[/SYSTEM_PROMPT]\";\n            } else if (role == \"user\") {\n                ss << \"[INST]\" << trailing_space << content << \"[/INST]\";\n            } else {\n                ss << trailing_space << content << \"</s>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V1\n            || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3\n            || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN) {\n        // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/chat_templates.md\n        // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/templates.md\n        std::string leading_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V1 ? \" \" : \"\";\n        std::string trailing_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN ? \"\" : \" \";\n        bool trim_assistant_message = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3;\n        bool is_inside_turn = false;\n        for (auto message : chat) {\n            if (!is_inside_turn) {\n                ss << leading_space << \"[INST]\" << trailing_space;\n                is_inside_turn = true;\n            }\n            std::string role(message->role);\n            std::string content(message->content);\n            if (role == \"system\") {\n                ss << content << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << content << leading_space << \"[/INST]\";\n            } else {\n                ss << trailing_space << (trim_assistant_message ? trim(content) : content) << \"</s>\";\n                is_inside_turn = false;\n            }\n        }\n    } else if (\n            tmpl == LLM_CHAT_TEMPLATE_LLAMA_2\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP) {\n        // llama2 template and its variants\n        // [variant] support system message\n        // See: https://huggingface.co/blog/llama2#how-to-prompt-llama-2\n        bool support_system_message = tmpl != LLM_CHAT_TEMPLATE_LLAMA_2;\n        // [variant] add BOS inside history\n        bool add_bos_inside_history = tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS;\n        // [variant] trim spaces from the input message\n        bool strip_message = tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP;\n        // construct the prompt\n        bool is_inside_turn = true; // skip BOS at the beginning\n        ss << \"[INST] \";\n        for (auto message : chat) {\n            std::string content = strip_message ? trim(message->content) : message->content;\n            std::string role(message->role);\n            if (!is_inside_turn) {\n                is_inside_turn = true;\n                ss << (add_bos_inside_history ? \"<s>[INST] \" : \"[INST] \");\n            }\n            if (role == \"system\") {\n                if (support_system_message) {\n                    ss << \"<<SYS>>\\n\" << content << \"\\n<</SYS>>\\n\\n\";\n                } else {\n                    // if the model does not support system message, we still include it in the first message, but without <<SYS>>\n                    ss << content << \"\\n\";\n                }\n            } else if (role == \"user\") {\n                ss << content << \" [/INST]\";\n            } else {\n                ss << content << \"</s>\";\n                is_inside_turn = false;\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_PHI_3) {\n        // Phi 3\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|\" << role << \"|>\\n\" << message->content << \"<|end|>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_PHI_4) {\n        // chatml template\n        for (auto message : chat) {\n            ss << \"<|im_start|>\" << message->role << \"<|im_sep|>\" << message->content << \"<|im_end|>\";\n        }\n        if (add_ass) {\n            ss << \"<|im_start|>assistant<|im_sep|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_FALCON_3) {\n        // Falcon 3\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|\" << role << \"|>\\n\" << message->content << \"\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_ZEPHYR) {\n        // zephyr template\n        for (auto message : chat) {\n            ss << \"<|\" << message->role << \"|>\" << \"\\n\" << message->content << \"<|endoftext|>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MONARCH) {\n        // mlabonne/AlphaMonarch-7B template (the <s> is included inside history)\n        for (auto message : chat) {\n            std::string bos = (message == chat.front()) ? \"\" : \"<s>\"; // skip BOS for first message\n            ss << bos << message->role << \"\\n\" << message->content << \"</s>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<s>assistant\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_GEMMA) {\n        // google/gemma-7b-it\n        std::string system_prompt = \"\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                // there is no system message for gemma, but we will merge it with user prompt, so nothing is broken\n                system_prompt += trim(message->content);\n                continue;\n            }\n            // in gemma, \"assistant\" is \"model\"\n            role = role == \"assistant\" ? \"model\" : message->role;\n            ss << \"<start_of_turn>\" << role << \"\\n\";\n            if (!system_prompt.empty() && role != \"model\") {\n                ss << system_prompt << \"\\n\\n\";\n                system_prompt = \"\";\n            }\n            ss << trim(message->content) << \"<end_of_turn>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<start_of_turn>model\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_ORION) {\n        // OrionStarAI/Orion-14B-Chat\n        std::string system_prompt = \"\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                // there is no system message support, we will merge it with user prompt\n                system_prompt += message->content;\n                continue;\n            } else if (role == \"user\") {\n                ss << \"Human: \";\n                if (!system_prompt.empty()) {\n                    ss << system_prompt << \"\\n\\n\";\n                    system_prompt = \"\";\n                }\n                ss << message->content << \"\\n\\nAssistant: </s>\";\n            } else {\n                ss << message->content << \"</s>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_OPENCHAT) {\n        // openchat/openchat-3.5-0106,\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << message->content << \"<|end_of_turn|>\";\n            } else {\n                role[0] = toupper(role[0]);\n                ss << \"GPT4 Correct \" << role << \": \" << message->content << \"<|end_of_turn|>\";\n            }\n        }\n        if (add_ass) {\n            ss << \"GPT4 Correct Assistant:\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_VICUNA || tmpl == LLM_CHAT_TEMPLATE_VICUNA_ORCA) {\n        // eachadea/vicuna-13b-1.1 (and Orca variant)\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                // Orca-Vicuna variant uses a system prefix\n                if (tmpl == LLM_CHAT_TEMPLATE_VICUNA_ORCA) {\n                    ss << \"SYSTEM: \" << message->content << \"\\n\";\n                } else {\n                    ss << message->content << \"\\n\\n\";\n                }\n            } else if (role == \"user\") {\n                ss << \"USER: \" << message->content << \"\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"ASSISTANT: \" << message->content << \"</s>\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"ASSISTANT:\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_DEEPSEEK) {\n        // deepseek-ai/deepseek-coder-33b-instruct\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << message->content;\n            } else if (role == \"user\") {\n                ss << \"### Instruction:\\n\" << message->content << \"\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"### Response:\\n\" << message->content << \"\\n<|EOT|>\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"### Response:\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_COMMAND_R) {\n        // CohereForAI/c4ai-command-r-plus\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"<|START_OF_TURN_TOKEN|><|SYSTEM_TOKEN|>\" << trim(message->content) << \"<|END_OF_TURN_TOKEN|>\";\n            } else if (role == \"user\") {\n                ss << \"<|START_OF_TURN_TOKEN|><|USER_TOKEN|>\" << trim(message->content) << \"<|END_OF_TURN_TOKEN|>\";\n            } else if (role == \"assistant\") {\n                ss << \"<|START_OF_TURN_TOKEN|><|CHATBOT_TOKEN|>\" << trim(message->content) << \"<|END_OF_TURN_TOKEN|>\";\n            }\n        }\n        if (add_ass) {\n            ss << \"<|START_OF_TURN_TOKEN|><|CHATBOT_TOKEN|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_LLAMA_3) {\n        // Llama 3\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|start_header_id|>\" << role << \"<|end_header_id|>\\n\\n\" << trim(message->content) << \"<|eot_id|>\";\n        }\n        if (add_ass) {\n            ss << \"<|start_header_id|>assistant<|end_header_id|>\\n\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_CHATGLM_3) {\n        // chatglm3-6b\n        ss << \"[gMASK]\" << \"sop\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|\" << role << \"|>\" << \"\\n \" << message->content;\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_CHATGLM_4) {\n        ss << \"[gMASK]\" << \"<sop>\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|\" << role << \"|>\" << \"\\n\" << message->content;\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_GLMEDGE) {\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|\" << role << \"|>\" << \"\\n\" << message->content;\n        }\n        if (add_ass) {\n            ss << \"<|assistant|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MINICPM) {\n        // MiniCPM-3B-OpenHermes-2.5-v2-GGUF\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"user\") {\n                ss << LU8(\"<用户>\");\n                ss << trim(message->content);\n                ss << \"<AI>\";\n            } else {\n                ss << trim(message->content);\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_DEEPSEEK_2) {\n        // DeepSeek-V2\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << message->content << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << \"User: \" << message->content << \"\\n\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"Assistant: \" << message->content << LU8(\"<｜end▁of▁sentence｜>\");\n            }\n        }\n        if (add_ass) {\n            ss << \"Assistant:\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_DEEPSEEK_3) {\n        // DeepSeek-V3\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << message->content << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << LU8(\"<｜User｜>\") << message->content;\n            } else if (role == \"assistant\") {\n                ss << LU8(\"<｜Assistant｜>\") << message->content << LU8(\"<｜end▁of▁sentence｜>\");\n            }\n        }\n        if (add_ass) {\n            ss << LU8(\"<｜Assistant｜>\");\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_EXAONE_3) {\n        // ref: https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct/discussions/8#66bae61b1893d14ee8ed85bb\n        // EXAONE-3.0-7.8B-Instruct\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"[|system|]\" << trim(message->content) << \"[|endofturn|]\\n\";\n            } else if (role == \"user\") {\n                ss << \"[|user|]\" << trim(message->content) << \"\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"[|assistant|]\" << trim(message->content) << \"[|endofturn|]\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"[|assistant|]\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_EXAONE_4) {\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"[|system|]\" << trim(message->content) << \"[|endofturn|]\\n\";\n            } else if (role == \"user\") {\n                ss << \"[|user|]\" << trim(message->content) << \"\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"[|assistant|]\" << trim(message->content) << \"[|endofturn|]\\n\";\n            } else if (role == \"tool\") {\n                ss << \"[|tool|]\" << trim(message->content) << \"[|endofturn|]\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"[|assistant|]\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_RWKV_WORLD) {\n        // this template requires the model to have \"\\n\\n\" as EOT token\n        for (size_t i = 0; i < chat.size(); i++) {\n            std::string role(chat[i]->role);\n            if (role == \"system\") {\n                ss << \"System: \" << trim(chat[i]->content) << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << \"User: \" << trim(chat[i]->content) << \"\\n\\n\";\n                if (i == chat.size() - 1) {\n                    ss << \"Assistant:\";\n                }\n            } else if (role == \"assistant\") {\n                ss << \"Assistant: \" << trim(chat[i]->content) << \"\\n\\n\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_GRANITE) {\n        // IBM Granite template\n        for (const auto & message : chat) {\n            std::string role(message->role);\n            ss << \"<|start_of_role|>\" << role << \"<|end_of_role|>\";\n            if (role == \"assistant_tool_call\") {\n                ss << \"<|tool_call|>\";\n            }\n            ss << message->content << \"<|end_of_text|>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|start_of_role|>assistant<|end_of_role|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_GIGACHAT) {\n        // GigaChat template\n        bool has_system = !chat.empty() && std::string(chat[0]->role) == \"system\";\n\n        // Handle system message if present\n        if (has_system) {\n            ss << \"<s>\" << chat[0]->content << \"<|message_sep|>\";\n        } else {\n            ss << \"<s>\";\n        }\n\n        // Process remaining messages\n        for (size_t i = has_system ? 1 : 0; i < chat.size(); i++) {\n            std::string role(chat[i]->role);\n            if (role == \"user\") {\n                ss << \"user<|role_sep|>\" << chat[i]->content << \"<|message_sep|>\"\n                << \"available functions<|role_sep|>[]<|message_sep|>\";\n            } else if (role == \"assistant\") {\n                ss << \"assistant<|role_sep|>\" << chat[i]->content << \"<|message_sep|>\";\n            }\n        }\n\n        // Add generation prompt if needed\n        if (add_ass) {\n            ss << \"assistant<|role_sep|>\";\n        }\n    }  else if (tmpl == LLM_CHAT_TEMPLATE_MEGREZ) {\n        // Megrez template\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|role_start|>\" << role << \"<|role_end|>\" << message->content << \"<|turn_end|>\";\n        }\n\n        if (add_ass) {\n            ss << \"<|role_start|>assistant<|role_end|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_YANDEX) {\n        // Yandex template (\"\\n\\n\" is defined as EOT token)\n\n        for (size_t i = 0; i < chat.size(); i++) {\n            std::string role(chat[i]->role);\n            if (role == \"user\") {\n                ss << \" Пользователь: \" << chat[i]->content << \"\\n\\n\";\n            } else if (role == \"assistant\") {\n                ss << \" Ассистент: \" << chat[i]->content << \"\\n\\n\";\n            }\n        }\n\n        // Add generation prompt if needed\n        if (add_ass) {\n            ss << \" Ассистент:[SEP]\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_BAILING || tmpl == LLM_CHAT_TEMPLATE_BAILING_THINK) {\n        // Bailing (Ling/Ring) template\n        for (auto message : chat) {\n            std::string role(message->role);\n\n            if (role == \"user\") {\n                role = \"HUMAN\";\n            } else {\n                std::transform(role.begin(), role.end(), role.begin(), ::toupper);\n            }\n\n            ss << \"<role>\" << role << \"</role>\" << message->content;\n        }\n\n        if (add_ass) {\n            ss << \"<role>ASSISTANT</role>\";\n\n            if (tmpl == LLM_CHAT_TEMPLATE_BAILING_THINK) {\n                ss << \"<think>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_BAILING2) {\n        // Bailing2 (Ling 2.0) template\n        bool has_system = !chat.empty() && std::string(chat[0]->role) == \"system\";\n\n        if (!has_system) {\n            ss << \"<role>SYSTEM</role>detailed thinking off<|role_end|>\";\n        }\n\n        for (auto message : chat) {\n            std::string role(message->role);\n\n            if (role == \"user\") {\n                role = \"HUMAN\";\n            } else {\n                std::transform(role.begin(), role.end(), role.begin(), ::toupper);\n            }\n\n            ss << \"<role>\" << role << \"</role>\" << message->content << \"<|role_end|>\";\n        }\n\n        if (add_ass) {\n            ss << \"<role>ASSISTANT</role>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_LLAMA4) {\n        // Llama 4\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|header_start|>\" << role << \"<|header_end|>\\n\\n\" << trim(message->content) << \"<|eot|>\";\n        }\n        if (add_ass) {\n            ss << \"<|header_start|>assistant<|header_end|>\\n\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_SMOLVLM) {\n        // SmolVLM\n        ss << \"<|im_start|>\"; // uses <|im_start|> as BOS, but the actual content is NOT chatml\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << message->content << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << \"User: \" << message->content << \"<end_of_utterance>\\n\";\n            } else {\n                ss << \"Assistant: \" << message->content << \"<end_of_utterance>\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"Assistant:\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_DOTS1) {\n        // dots.llm1.inst (DOTS1)\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"<|system|>\" << message->content << \"<|endofsystem|>\";\n            } else if (role == \"user\") {\n                ss << \"<|userprompt|>\" << message->content << \"<|endofuserprompt|>\";\n            } else {\n                ss << \"<|response|>\" << message->content << \"<|endofresponse|>\";\n            }\n        }\n        if (add_ass) {\n            ss << \"<|response|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_HUNYUAN_MOE) {\n        // tencent/Hunyuan-A13B-Instruct\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"<|startoftext|>\" << message->content << \"<|extra_4|>\";\n            } else if (role == \"assistant\") {\n                ss << message->content << \"<|eos|>\";\n            } else {\n                ss << \"<|startoftext|>\" << message->content << \"<|extra_0|>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_OPENAI_MOE) {\n        // OpenAI MoE (based on Harmony chat template)\n        for (auto message : chat) {\n            std::string role(message->role);\n            ss << \"<|start|>\" << role << \"<|message|>\" << message->content;\n            ss << (role == \"assistant\" ? \"<|return|>\" : \"<|end|>\");\n        }\n        if (add_ass) {\n            ss << \"<|start|>assistant\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_HUNYUAN_DENSE) {\n        // tencent/Hunyuan-4B-Instruct\n        for (size_t i = 0; i < chat.size(); i++) {\n            std::string role(chat[i]->role);\n            if (i == 0) {\n                if (role == \"system\") {\n                    ss << chat[i]->content << \"<｜hy_place▁holder▁no▁3｜>\";\n                }\n            }\n\n            if (role == \"assistant\") {\n                ss << \"<｜hy_Assistant｜>\" << chat[i]->content << \"<｜hy_place▁holder▁no▁2｜>\";\n            } else if (role == \"user\") {\n                ss << \"<｜hy_User｜>\" << chat[i]->content << \"<｜hy_Assistant｜>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_KIMI_K2) {\n        // moonshotai/Kimi-K2-Instruct\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"<|im_system|>system<|im_middle|>\";\n            } else if (role == \"user\") {\n                ss << \"<|im_user|>user<|im_middle|>\";\n            } else if (role == \"assistant\") {\n                ss << \"<|im_assistant|>assistant<|im_middle|>\";\n            } else if (role == \"tool\") {\n                ss << \"<|im_system|>tool<|im_middle|>\";\n            }\n\n            ss << message->content << \"<|im_end|>\";\n        }\n        if (add_ass) {\n            ss << \"<|im_assistant|>assistant<|im_middle|>\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_SEED_OSS) {\n        for (auto message: chat) {\n            std::string role(message->role);\n            ss << \"<seed:bos>\" << role << \"\\n\" << (role == \"assistant\" ? trim(message->content) : message->content) << \"<seed:eos>\";\n        }\n        if (add_ass) {\n            ss << \"<seed:bos>assistant\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_GROK_2) {\n        for (auto message : chat) {\n            std::string role(message->role);\n            if (role == \"system\") {\n                ss << \"System: \" << trim(message->content) << \"<|separator|>\\n\\n\";\n            } else if (role == \"user\") {\n                ss << \"Human: \" << trim(message->content) << \"<|separator|>\\n\\n\";\n            } else if (role == \"assistant\") {\n                ss << \"Assistant: \" << message->content << \"<|separator|>\\n\\n\";\n            }\n        }\n        if (add_ass) {\n            ss << \"Assistant:\";\n        }\n    } else {\n        // template not supported\n        return -1;\n    }\n    dest = ss.str();\n    return dest.size();\n}"
  },
  {
    "id": "108215be7d175c9085f491b67531fe95ad463570",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/llama-chat.cpp",
    "kind": "function",
    "name": "tmpl",
    "signature": "llm_chat_detect_template(const std::string & tmpl)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "add_bos_inside_history",
      "find",
      "haystack",
      "llm_chat_detect_template",
      "llm_chat_template",
      "llm_chat_template_bailing",
      "llm_chat_template_bailing2",
      "llm_chat_template_bailing_think",
      "llm_chat_template_chatglm_3",
      "llm_chat_template_chatglm_4",
      "llm_chat_template_chatml",
      "llm_chat_template_command_r",
      "llm_chat_template_deepseek",
      "llm_chat_template_deepseek_2",
      "llm_chat_template_deepseek_3",
      "llm_chat_template_dots1",
      "llm_chat_template_exaone_3",
      "llm_chat_template_exaone_4",
      "llm_chat_template_falcon_3",
      "llm_chat_template_from_str",
      "llm_chat_template_gemma",
      "llm_chat_template_gigachat",
      "llm_chat_template_glmedge",
      "llm_chat_template_granite",
      "llm_chat_template_grok_2",
      "llm_chat_template_hunyuan_dense",
      "llm_chat_template_hunyuan_moe",
      "llm_chat_template_kimi_k2",
      "llm_chat_template_llama4",
      "llm_chat_template_llama_2",
      "llm_chat_template_llama_2_sys",
      "llm_chat_template_llama_2_sys_bos",
      "llm_chat_template_llama_2_sys_strip",
      "llm_chat_template_llama_3",
      "llm_chat_template_megrez",
      "llm_chat_template_minicpm",
      "llm_chat_template_mistral_v1",
      "llm_chat_template_mistral_v3",
      "llm_chat_template_mistral_v3_tekken",
      "llm_chat_template_mistral_v7",
      "llm_chat_template_monarch",
      "llm_chat_template_openai_moe",
      "llm_chat_template_openchat",
      "llm_chat_template_orion",
      "llm_chat_template_phi_3",
      "llm_chat_template_phi_4",
      "llm_chat_template_rwkv_world",
      "llm_chat_template_seed_oss",
      "llm_chat_template_smolvlm",
      "llm_chat_template_unknown",
      "llm_chat_template_vicuna",
      "llm_chat_template_vicuna_orca",
      "llm_chat_template_yandex",
      "llm_chat_template_zephyr",
      "lu8",
      "npos",
      "out_of_range",
      "string",
      "strip_message",
      "support_system_message",
      "tmpl",
      "tmpl_contains"
    ],
    "start_line": 82,
    "end_line": 218,
    "text": "llm_chat_template llm_chat_detect_template(const std::string & tmpl) {\n    try {\n        return llm_chat_template_from_str(tmpl);\n    } catch (const std::out_of_range &) {\n        // ignore\n    }\n\n    auto tmpl_contains = [&tmpl](const char * haystack) -> bool {\n        return tmpl.find(haystack) != std::string::npos;\n    };\n    if (tmpl_contains(\"<|im_start|>\")) {\n        return tmpl_contains(\"<|im_sep|>\")\n            ? LLM_CHAT_TEMPLATE_PHI_4\n            : tmpl_contains(\"<end_of_utterance>\")\n                ? LLM_CHAT_TEMPLATE_SMOLVLM // SmolVLM uses <|im_start|> as BOS, but it is NOT chatml\n                : LLM_CHAT_TEMPLATE_CHATML;\n    } else if (tmpl.find(\"mistral\") == 0 || tmpl_contains(\"[INST]\")) {\n        if (tmpl_contains(\"[SYSTEM_PROMPT]\")) {\n            return LLM_CHAT_TEMPLATE_MISTRAL_V7;\n        } else if (\n            // catches official 'v1' template\n            tmpl_contains(\"' [INST] ' + system_message\")\n            // catches official 'v3' and 'v3-tekken' templates\n            || tmpl_contains(\"[AVAILABLE_TOOLS]\")\n        ) {\n            // Official mistral 'v1', 'v3' and 'v3-tekken' templates\n            // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/chat_templates.md\n            // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/templates.md\n            if (tmpl_contains(\" [INST]\")) {\n                return LLM_CHAT_TEMPLATE_MISTRAL_V1;\n            } else if (tmpl_contains(\"\\\"[INST]\\\"\")) {\n                return LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN;\n            }\n            return LLM_CHAT_TEMPLATE_MISTRAL_V3;\n        } else {\n            // llama2 template and its variants\n            // [variant] support system message\n            // See: https://huggingface.co/blog/llama2#how-to-prompt-llama-2\n            bool support_system_message = tmpl_contains(\"<<SYS>>\");\n            bool add_bos_inside_history = tmpl_contains(\"bos_token + '[INST]\");\n            bool strip_message = tmpl_contains(\"content.strip()\");\n            if (strip_message) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP;\n            } else if (add_bos_inside_history) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS;\n            } else if (support_system_message) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS;\n            } else {\n                return LLM_CHAT_TEMPLATE_LLAMA_2;\n            }\n        }\n    } else if (tmpl_contains(\"<|assistant|>\") && tmpl_contains(\"<|end|>\")) {\n        return LLM_CHAT_TEMPLATE_PHI_3;\n    } else if (tmpl_contains(\"[gMASK]<sop>\")) {\n        return LLM_CHAT_TEMPLATE_CHATGLM_4;\n    } else if (tmpl_contains(\"<|assistant|>\") && tmpl_contains(\"<|user|>\")) {\n        return tmpl_contains(\"</s>\") ? LLM_CHAT_TEMPLATE_FALCON_3 : LLM_CHAT_TEMPLATE_GLMEDGE;\n    } else if (tmpl_contains(\"<|{{ item['role'] }}|>\") && tmpl_contains(\"<|begin_of_image|>\")) {\n        return LLM_CHAT_TEMPLATE_GLMEDGE;\n    } else if (tmpl_contains(\"<|user|>\") && tmpl_contains(\"<|endoftext|>\")) {\n        return LLM_CHAT_TEMPLATE_ZEPHYR;\n    } else if (tmpl_contains(\"bos_token + message['role']\")) {\n        return LLM_CHAT_TEMPLATE_MONARCH;\n    } else if (tmpl_contains(\"<start_of_turn>\")) {\n        return LLM_CHAT_TEMPLATE_GEMMA;\n    } else if (tmpl_contains(\"'\\\\n\\\\nAssistant: ' + eos_token\")) {\n        // OrionStarAI/Orion-14B-Chat\n        return LLM_CHAT_TEMPLATE_ORION;\n    } else if (tmpl_contains(\"GPT4 Correct \")) {\n        // openchat/openchat-3.5-0106\n        return LLM_CHAT_TEMPLATE_OPENCHAT;\n    } else if (tmpl_contains(\"USER: \") && tmpl_contains(\"ASSISTANT: \")) {\n        // eachadea/vicuna-13b-1.1 (and Orca variant)\n        if (tmpl_contains(\"SYSTEM: \")) {\n            return LLM_CHAT_TEMPLATE_VICUNA_ORCA;\n        }\n        return LLM_CHAT_TEMPLATE_VICUNA;\n    } else if (tmpl_contains(\"### Instruction:\") && tmpl_contains(\"<|EOT|>\")) {\n        // deepseek-ai/deepseek-coder-33b-instruct\n        return LLM_CHAT_TEMPLATE_DEEPSEEK;\n    } else if (tmpl_contains(\"<|START_OF_TURN_TOKEN|>\") && tmpl_contains(\"<|USER_TOKEN|>\")) {\n        // CohereForAI/c4ai-command-r-plus\n        return LLM_CHAT_TEMPLATE_COMMAND_R;\n    } else if (tmpl_contains(\"<|start_header_id|>\") && tmpl_contains(\"<|end_header_id|>\")) {\n        return LLM_CHAT_TEMPLATE_LLAMA_3;\n    } else if (tmpl_contains(\"[gMASK]sop\")) {\n        // chatglm3-6b\n        return LLM_CHAT_TEMPLATE_CHATGLM_3;\n    } else if (tmpl_contains(LU8(\"<用户>\"))) {\n        // MiniCPM-3B-OpenHermes-2.5-v2-GGUF\n        return LLM_CHAT_TEMPLATE_MINICPM;\n    } else if (tmpl_contains(\"'Assistant: ' + message['content'] + eos_token\")) {\n        return LLM_CHAT_TEMPLATE_DEEPSEEK_2;\n    } else if (tmpl_contains(LU8(\"<｜Assistant｜>\")) && tmpl_contains(LU8(\"<｜User｜>\")) && tmpl_contains(LU8(\"<｜end▁of▁sentence｜>\"))) {\n        return LLM_CHAT_TEMPLATE_DEEPSEEK_3;\n    } else if (tmpl_contains(\"[|system|]\") && tmpl_contains(\"[|assistant|]\") && tmpl_contains(\"[|endofturn|]\")) {\n        if (tmpl_contains(\"[|tool|]\")) {\n            return LLM_CHAT_TEMPLATE_EXAONE_4;\n        }\n        // ref: https://huggingface.co/LGAI-EXAONE/EXAONE-3.0-7.8B-Instruct/discussions/8#66bae61b1893d14ee8ed85bb\n        // EXAONE-3.0-7.8B-Instruct\n        return LLM_CHAT_TEMPLATE_EXAONE_3;\n    } else if (tmpl_contains(\"rwkv-world\") || tmpl_contains(\"{{- 'User: ' + message['content']|trim + '\\\\n\\\\n' -}}\")) {\n        return LLM_CHAT_TEMPLATE_RWKV_WORLD;\n    } else if (tmpl_contains(\"<|start_of_role|>\")) {\n        return LLM_CHAT_TEMPLATE_GRANITE;\n    } else if (tmpl_contains(\"message['role'] + additional_special_tokens[0] + message['content'] + additional_special_tokens[1]\")) {\n        return LLM_CHAT_TEMPLATE_GIGACHAT;\n    } else if (tmpl_contains(\"<|role_start|>\")) {\n        return LLM_CHAT_TEMPLATE_MEGREZ;\n    } else if (tmpl_contains(\" Ассистент:\")) {\n        return LLM_CHAT_TEMPLATE_YANDEX;\n    } else if (tmpl_contains(\"<role>ASSISTANT</role>\") && tmpl_contains(\"'HUMAN'\")) {\n        return LLM_CHAT_TEMPLATE_BAILING;\n    } else if (tmpl_contains(\"<role>ASSISTANT</role>\") && tmpl_contains(\"\\\"HUMAN\\\"\") && tmpl_contains(\"<think>\")) {\n        return LLM_CHAT_TEMPLATE_BAILING_THINK;\n    } else if (tmpl_contains(\"<role>ASSISTANT</role>\") && tmpl_contains(\"<role>HUMAN</role>\") && tmpl_contains(\"<|role_end|>\")) {\n        return LLM_CHAT_TEMPLATE_BAILING2;\n    } else if (tmpl_contains(\"<|header_start|>\") && tmpl_contains(\"<|header_end|>\")) {\n        return LLM_CHAT_TEMPLATE_LLAMA4;\n    } else if (tmpl_contains(\"<|endofuserprompt|>\")) {\n        return LLM_CHAT_TEMPLATE_DOTS1;\n    } else if (tmpl_contains(\"<|extra_0|>\") && tmpl_contains(\"<|extra_4|>\")) {\n        return LLM_CHAT_TEMPLATE_HUNYUAN_MOE;\n    } else if (tmpl_contains(\"<|start|>\") && tmpl_contains(\"<|channel|>\")) {\n        return LLM_CHAT_TEMPLATE_OPENAI_MOE;\n    } else if (tmpl_contains(\"<｜hy_Assistant｜>\") && tmpl_contains(\"<｜hy_place▁holder▁no▁3｜>\")) {\n        return LLM_CHAT_TEMPLATE_HUNYUAN_DENSE;\n    } else if (tmpl_contains(\"<|im_assistant|>assistant<|im_middle|>\")) {\n        return LLM_CHAT_TEMPLATE_KIMI_K2;\n    } else if (tmpl_contains(\"<seed:bos>\")) {\n        return LLM_CHAT_TEMPLATE_SEED_OSS;\n    } else if (tmpl_contains(\"'Assistant: '  + message['content'] + '<|separator|>\")) {\n        return LLM_CHAT_TEMPLATE_GROK_2;\n    }\n    return LLM_CHAT_TEMPLATE_UNKNOWN;\n}"
  },
  {
    "id": "92d81d197e181fee9b035dc01af3cb0b2821f9e5",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/llama-chat.cpp",
    "kind": "function",
    "name": "name",
    "signature": "llm_chat_template_from_str(const std::string & name)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "at",
      "llm_chat_template",
      "llm_chat_template_from_str",
      "llm_chat_templates",
      "name",
      "string"
    ],
    "start_line": 78,
    "end_line": 80,
    "text": "llm_chat_template llm_chat_template_from_str(const std::string & name) {\n    return LLM_CHAT_TEMPLATES.at(name);\n}"
  },
  {
    "id": "62a5a6f348c563529bf5b72524ed5b4bf84224f0",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/llama-chat.cpp",
    "kind": "function",
    "name": "str",
    "signature": "trim(const std::string & str)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "end",
      "isspace",
      "size",
      "start",
      "static_cast",
      "str",
      "string",
      "substr",
      "trim"
    ],
    "start_line": 16,
    "end_line": 26,
    "text": "static std::string trim(const std::string & str) {\n    size_t start = 0;\n    size_t end = str.size();\n    while (start < end && isspace(static_cast<unsigned char>(str[start]))) {\n        start += 1;\n    }\n    while (end > start && isspace(static_cast<unsigned char>(str[end - 1]))) {\n        end -= 1;\n    }\n    return str.substr(start, end - start);\n}"
  },
  {
    "id": "f509adb4c7cae82c9cb74fec1ef8b2964e792fd7",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "class",
    "name": "HierholzerEulerianPath",
    "signature": "HierholzerEulerianPath",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>",
    "identifiers": [
      "abs",
      "add",
      "addedge",
      "adjacencylist",
      "allnonzerodegreeverticesweaklyconnected",
      "arraydeque",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "computedegrees",
      "currentindex",
      "deque",
      "determinestartnode",
      "diff",
      "edgecount",
      "endcount",
      "findeulerianpath",
      "from",
      "get",
      "getedges",
      "getnumnodes",
      "graph",
      "hierholzereulerianpath",
      "i",
      "idx",
      "indegree",
      "integer",
      "isempty",
      "length",
      "list",
      "math",
      "n",
      "node",
      "numnodes",
      "outdegree",
      "path",
      "peek",
      "pollfirst",
      "pop",
      "preferredstart",
      "push",
      "reverse",
      "rotated",
      "rotateeuleriancircuitifneeded",
      "singletonlist",
      "size",
      "stack",
      "startcount",
      "startnode",
      "tempadj",
      "to",
      "u",
      "v",
      "visited",
      "x",
      "y"
    ],
    "start_line": 38,
    "end_line": 303,
    "text": "public class HierholzerEulerianPath {\n\n    /**\n     * Simple directed graph represented by adjacency lists.\n     */\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\n         * Constructs a graph with a given number of vertices.\n         *\n         * @param numNodes number of vertices\n         */\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\n         * Adds a directed edge from vertex {@code from} to vertex {@code to}.\n         *\n         * @param from source vertex\n         * @param to   destination vertex\n         */\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\n         * Returns a list of outgoing edges from the given vertex.\n         *\n         * @param node vertex index\n         * @return list of destination vertices\n         */\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\n         * Returns the number of vertices in the graph.\n         *\n         * @return number of vertices\n         */\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }\n\n    private final Graph graph;\n\n    /**\n     * Creates a Hierholzer solver for the given graph.\n     *\n     * @param graph directed graph\n     */\n    public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }\n\n    /**\n     * Finds an Eulerian Path or Circuit using Hierholzer’s Algorithm.\n     *\n     * @return list of vertices representing the Eulerian Path/Circuit,\n     *         or an empty list if none exists\n     */\n    public List<Integer> findEulerianPath() {\n        int n = graph.getNumNodes();\n\n        // empty graph -> no path\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        int[] inDegree = new int[n];\n        int[] outDegree = new int[n];\n        int edgeCount = computeDegrees(inDegree, outDegree);\n\n        // no edges -> single vertex response requested by tests: [0]\n        if (edgeCount == 0) {\n            return Collections.singletonList(0);\n        }\n\n        int startNode = determineStartNode(inDegree, outDegree);\n        if (startNode == -1) {\n            return new ArrayList<>();\n        }\n\n        if (!allNonZeroDegreeVerticesWeaklyConnected(startNode, n, outDegree, inDegree)) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> path = buildHierholzerPath(startNode, n);\n        if (path.size() != edgeCount + 1) {\n            return new ArrayList<>();\n        }\n\n        return rotateEulerianCircuitIfNeeded(path, outDegree, inDegree);\n    }\n\n    private int computeDegrees(int[] inDegree, int[] outDegree) {\n        int edgeCount = 0;\n        for (int u = 0; u < graph.getNumNodes(); u++) {\n            for (int v : graph.getEdges(u)) {\n                outDegree[u]++;\n                inDegree[v]++;\n                edgeCount++;\n            }\n        }\n        return edgeCount;\n    }\n\n    private int determineStartNode(int[] inDegree, int[] outDegree) {\n        int n = graph.getNumNodes();\n        int startNode = -1;\n        int startCount = 0;\n        int endCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startNode = i;\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            } else if (Math.abs(diff) > 1) {\n                return -1;\n            }\n        }\n\n        if (!((startCount == 1 && endCount == 1) || (startCount == 0 && endCount == 0))) {\n            return -1;\n        }\n\n        if (startNode == -1) {\n            for (int i = 0; i < n; i++) {\n                if (outDegree[i] > 0) {\n                    startNode = i;\n                    break;\n                }\n            }\n        }\n        return startNode;\n    }\n\n    private List<Integer> buildHierholzerPath(int startNode, int n) {\n        List<Deque<Integer>> tempAdj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tempAdj.add(new ArrayDeque<>(graph.getEdges(i)));\n        }\n\n        Deque<Integer> stack = new ArrayDeque<>();\n        List<Integer> path = new ArrayList<>();\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int u = stack.peek();\n            if (!tempAdj.get(u).isEmpty()) {\n                stack.push(tempAdj.get(u).pollFirst());\n            } else {\n                path.add(stack.pop());\n            }\n        }\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    private List<Integer> rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree) {\n        int startCount = 0;\n        int endCount = 0;\n        for (int i = 0; i < outDegree.length; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            }\n        }\n\n        if (startCount == 0 && endCount == 0 && !path.isEmpty()) {\n            int preferredStart = -1;\n            for (int i = 0; i < outDegree.length; i++) {\n                if (outDegree[i] > 0) {\n                    preferredStart = i;\n                    break;\n                }\n            }\n\n            if (preferredStart != -1 && path.get(0) != preferredStart) {\n                int idx = 0;\n                for (Integer node : path) { // replaced indexed loop\n                    if (node == preferredStart) {\n                        break;\n                    }\n                    idx++;\n                }\n\n                if (idx > 0) {\n                    List<Integer> rotated = new ArrayList<>();\n                    int currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex >= idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex < idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    path = rotated;\n                }\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Checks weak connectivity (undirected) among vertices that have non-zero degree.\n     *\n     * @param startNode node to start DFS from (must be a vertex with non-zero degree)\n     * @param n number of vertices\n     * @param outDegree out-degree array\n     * @param inDegree in-degree array\n     * @return true if all vertices having non-zero degree belong to a single weak component\n     */\n    private boolean allNonZeroDegreeVerticesWeaklyConnected(int startNode, int n, int[] outDegree, int[] inDegree) {\n        boolean[] visited = new boolean[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(startNode);\n        visited[startNode] = true;\n\n        while (!stack.isEmpty()) {\n            int u = stack.pop();\n            for (int v : graph.getEdges(u)) {\n                if (!visited[v]) {\n                    visited[v] = true;\n                    stack.push(v);\n                }\n            }\n            for (int x = 0; x < n; x++) {\n                if (!visited[x]) {\n                    for (int y : graph.getEdges(x)) {\n                        if (y == u) {\n                            visited[x] = true;\n                            stack.push(x);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (outDegree[i] + inDegree[i] > 0 && !visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "id": "c950d080efc58a6b25d25d0d5c751f04c4461add",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "allNonZeroDegreeVerticesWeaklyConnected",
    "signature": "allNonZeroDegreeVerticesWeaklyConnected(int startNode, int n, int[] outDegree, int[] inDegree)",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\nReturns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\nReturns the number of vertices in the graph.\n\n@return number of vertices\n/\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }\n\n    private final Graph graph;\n\n    /**\nCreates a Hierholzer solver for the given graph.\n\n@param graph directed graph\n/\n    public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }\n\n    /**\nFinds an Eulerian Path or Circuit using Hierholzer’s Algorithm.\n\n@return list of vertices representing the Eulerian Path/Circuit,\n        or an empty list if none exists\n/\n    public List<Integer> findEulerianPath() {\n        int n = graph.getNumNodes();\n\n        // empty graph -> no path\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        int[] inDegree = new int[n];\n        int[] outDegree = new int[n];\n        int edgeCount = computeDegrees(inDegree, outDegree);\n\n        // no edges -> single vertex response requested by tests: [0]\n        if (edgeCount == 0) {\n            return Collections.singletonList(0);\n        }\n\n        int startNode = determineStartNode(inDegree, outDegree);\n        if (startNode == -1) {\n            return new ArrayList<>();\n        }\n\n        if (!allNonZeroDegreeVerticesWeaklyConnected(startNode, n, outDegree, inDegree)) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> path = buildHierholzerPath(startNode, n);\n        if (path.size() != edgeCount + 1) {\n            return new ArrayList<>();\n        }\n\n        return rotateEulerianCircuitIfNeeded(path, outDegree, inDegree);\n    }\n\n    private int computeDegrees(int[] inDegree, int[] outDegree) {\n        int edgeCount = 0;\n        for (int u = 0; u < graph.getNumNodes(); u++) {\n            for (int v : graph.getEdges(u)) {\n                outDegree[u]++;\n                inDegree[v]++;\n                edgeCount++;\n            }\n        }\n        return edgeCount;\n    }\n\n    private int determineStartNode(int[] inDegree, int[] outDegree) {\n        int n = graph.getNumNodes();\n        int startNode = -1;\n        int startCount = 0;\n        int endCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startNode = i;\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            } else if (Math.abs(diff) > 1) {\n                return -1;\n            }\n        }\n\n        if (!((startCount == 1 && endCount == 1) || (startCount == 0 && endCount == 0))) {\n            return -1;\n        }\n\n        if (startNode == -1) {\n            for (int i = 0; i < n; i++) {\n                if (outDegree[i] > 0) {\n                    startNode = i;\n                    break;\n                }\n            }\n        }\n        return startNode;\n    }\n\n    private List<Integer> buildHierholzerPath(int startNode, int n) {\n        List<Deque<Integer>> tempAdj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tempAdj.add(new ArrayDeque<>(graph.getEdges(i)));\n        }\n\n        Deque<Integer> stack = new ArrayDeque<>();\n        List<Integer> path = new ArrayList<>();\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int u = stack.peek();\n            if (!tempAdj.get(u).isEmpty()) {\n                stack.push(tempAdj.get(u).pollFirst());\n            } else {\n                path.add(stack.pop());\n            }\n        }\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    private List<Integer> rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree) {\n        int startCount = 0;\n        int endCount = 0;\n        for (int i = 0; i < outDegree.length; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            }\n        }\n\n        if (startCount == 0 && endCount == 0 && !path.isEmpty()) {\n            int preferredStart = -1;\n            for (int i = 0; i < outDegree.length; i++) {\n                if (outDegree[i] > 0) {\n                    preferredStart = i;\n                    break;\n                }\n            }\n\n            if (preferredStart != -1 && path.get(0) != preferredStart) {\n                int idx = 0;\n                for (Integer node : path) { // replaced indexed loop\n                    if (node == preferredStart) {\n                        break;\n                    }\n                    idx++;\n                }\n\n                if (idx > 0) {\n                    List<Integer> rotated = new ArrayList<>();\n                    int currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex >= idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex < idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    path = rotated;\n                }\n            }\n        }\n        return path;\n    }\n\n    /**\nChecks weak connectivity (undirected) among vertices that have non-zero degree.\n\n@param startNode node to start DFS from (must be a vertex with non-zero degree)\n@param n number of vertices\n@param outDegree out-degree array\n@param inDegree in-degree array\n@return true if all vertices having non-zero degree belong to a single weak component\n/",
    "identifiers": [
      "allnonzerodegreeverticesweaklyconnected",
      "arraydeque",
      "deque",
      "getedges",
      "graph",
      "i",
      "indegree",
      "integer",
      "isempty",
      "n",
      "outdegree",
      "pop",
      "push",
      "stack",
      "startnode",
      "u",
      "v",
      "visited",
      "x",
      "y"
    ],
    "start_line": 269,
    "end_line": 302,
    "text": "private boolean allNonZeroDegreeVerticesWeaklyConnected(int startNode, int n, int[] outDegree, int[] inDegree) {\n        boolean[] visited = new boolean[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(startNode);\n        visited[startNode] = true;\n\n        while (!stack.isEmpty()) {\n            int u = stack.pop();\n            for (int v : graph.getEdges(u)) {\n                if (!visited[v]) {\n                    visited[v] = true;\n                    stack.push(v);\n                }\n            }\n            for (int x = 0; x < n; x++) {\n                if (!visited[x]) {\n                    for (int y : graph.getEdges(x)) {\n                        if (y == u) {\n                            visited[x] = true;\n                            stack.push(x);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (outDegree[i] + inDegree[i] > 0 && !visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }"
  },
  {
    "id": "e71c5c92268839d7199beaf342cb1d24150cc613",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "rotateEulerianCircuitIfNeeded",
    "signature": "rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree)",
    "docstring": "empty graph -> no path",
    "identifiers": [
      "add",
      "arraylist",
      "currentindex",
      "diff",
      "endcount",
      "get",
      "i",
      "idx",
      "indegree",
      "integer",
      "isempty",
      "length",
      "list",
      "node",
      "outdegree",
      "path",
      "preferredstart",
      "rotated",
      "rotateeuleriancircuitifneeded",
      "startcount"
    ],
    "start_line": 207,
    "end_line": 258,
    "text": "private List<Integer> rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree) {\n        int startCount = 0;\n        int endCount = 0;\n        for (int i = 0; i < outDegree.length; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            }\n        }\n\n        if (startCount == 0 && endCount == 0 && !path.isEmpty()) {\n            int preferredStart = -1;\n            for (int i = 0; i < outDegree.length; i++) {\n                if (outDegree[i] > 0) {\n                    preferredStart = i;\n                    break;\n                }\n            }\n\n            if (preferredStart != -1 && path.get(0) != preferredStart) {\n                int idx = 0;\n                for (Integer node : path) { // replaced indexed loop\n                    if (node == preferredStart) {\n                        break;\n                    }\n                    idx++;\n                }\n\n                if (idx > 0) {\n                    List<Integer> rotated = new ArrayList<>();\n                    int currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex >= idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex < idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    path = rotated;\n                }\n            }\n        }\n        return path;\n    }"
  },
  {
    "id": "1f0eec763de86f4df68e39735267b838645f44d4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "buildHierholzerPath",
    "signature": "buildHierholzerPath(int startNode, int n)",
    "docstring": "empty graph -> no path",
    "identifiers": [
      "add",
      "arraydeque",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "deque",
      "get",
      "getedges",
      "graph",
      "i",
      "integer",
      "isempty",
      "list",
      "n",
      "path",
      "peek",
      "pollfirst",
      "pop",
      "push",
      "reverse",
      "stack",
      "startnode",
      "tempadj",
      "u"
    ],
    "start_line": 184,
    "end_line": 205,
    "text": "private List<Integer> buildHierholzerPath(int startNode, int n) {\n        List<Deque<Integer>> tempAdj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tempAdj.add(new ArrayDeque<>(graph.getEdges(i)));\n        }\n\n        Deque<Integer> stack = new ArrayDeque<>();\n        List<Integer> path = new ArrayList<>();\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int u = stack.peek();\n            if (!tempAdj.get(u).isEmpty()) {\n                stack.push(tempAdj.get(u).pollFirst());\n            } else {\n                path.add(stack.pop());\n            }\n        }\n\n        Collections.reverse(path);\n        return path;\n    }"
  },
  {
    "id": "cff17e2e9b9467682e19777efa371db514bec956",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "determineStartNode",
    "signature": "determineStartNode(int[] inDegree, int[] outDegree)",
    "docstring": "empty graph -> no path",
    "identifiers": [
      "abs",
      "determinestartnode",
      "diff",
      "endcount",
      "getnumnodes",
      "graph",
      "i",
      "indegree",
      "math",
      "n",
      "outdegree",
      "startcount",
      "startnode"
    ],
    "start_line": 151,
    "end_line": 182,
    "text": "private int determineStartNode(int[] inDegree, int[] outDegree) {\n        int n = graph.getNumNodes();\n        int startNode = -1;\n        int startCount = 0;\n        int endCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startNode = i;\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            } else if (Math.abs(diff) > 1) {\n                return -1;\n            }\n        }\n\n        if (!((startCount == 1 && endCount == 1) || (startCount == 0 && endCount == 0))) {\n            return -1;\n        }\n\n        if (startNode == -1) {\n            for (int i = 0; i < n; i++) {\n                if (outDegree[i] > 0) {\n                    startNode = i;\n                    break;\n                }\n            }\n        }\n        return startNode;\n    }"
  },
  {
    "id": "dd860324935419aee77742115ea7e49bc00e3330",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "computeDegrees",
    "signature": "computeDegrees(int[] inDegree, int[] outDegree)",
    "docstring": "empty graph -> no path",
    "identifiers": [
      "computedegrees",
      "edgecount",
      "getedges",
      "getnumnodes",
      "graph",
      "indegree",
      "outdegree",
      "u",
      "v"
    ],
    "start_line": 139,
    "end_line": 149,
    "text": "private int computeDegrees(int[] inDegree, int[] outDegree) {\n        int edgeCount = 0;\n        for (int u = 0; u < graph.getNumNodes(); u++) {\n            for (int v : graph.getEdges(u)) {\n                outDegree[u]++;\n                inDegree[v]++;\n                edgeCount++;\n            }\n        }\n        return edgeCount;\n    }"
  },
  {
    "id": "b7b63f739947495006ae42b54c72a6318fe25d1a",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "findEulerianPath",
    "signature": "findEulerianPath()",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\nReturns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\nReturns the number of vertices in the graph.\n\n@return number of vertices\n/\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }\n\n    private final Graph graph;\n\n    /**\nCreates a Hierholzer solver for the given graph.\n\n@param graph directed graph\n/\n    public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }\n\n    /**\nFinds an Eulerian Path or Circuit using Hierholzer’s Algorithm.\n\n@return list of vertices representing the Eulerian Path/Circuit,\n        or an empty list if none exists\n/",
    "identifiers": [
      "allnonzerodegreeverticesweaklyconnected",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "computedegrees",
      "determinestartnode",
      "edgecount",
      "findeulerianpath",
      "getnumnodes",
      "graph",
      "indegree",
      "integer",
      "list",
      "n",
      "outdegree",
      "path",
      "rotateeuleriancircuitifneeded",
      "singletonlist",
      "size",
      "startnode"
    ],
    "start_line": 105,
    "end_line": 137,
    "text": "public List<Integer> findEulerianPath() {\n        int n = graph.getNumNodes();\n\n        // empty graph -> no path\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        int[] inDegree = new int[n];\n        int[] outDegree = new int[n];\n        int edgeCount = computeDegrees(inDegree, outDegree);\n\n        // no edges -> single vertex response requested by tests: [0]\n        if (edgeCount == 0) {\n            return Collections.singletonList(0);\n        }\n\n        int startNode = determineStartNode(inDegree, outDegree);\n        if (startNode == -1) {\n            return new ArrayList<>();\n        }\n\n        if (!allNonZeroDegreeVerticesWeaklyConnected(startNode, n, outDegree, inDegree)) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> path = buildHierholzerPath(startNode, n);\n        if (path.size() != edgeCount + 1) {\n            return new ArrayList<>();\n        }\n\n        return rotateEulerianCircuitIfNeeded(path, outDegree, inDegree);\n    }"
  },
  {
    "id": "082e00129d1ab1aa91c6af6cf351d95cff47c48c",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "constructor",
    "name": "HierholzerEulerianPath",
    "signature": "HierholzerEulerianPath(Graph graph)",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\nReturns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\nReturns the number of vertices in the graph.\n\n@return number of vertices\n/\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }\n\n    private final Graph graph;\n\n    /**\nCreates a Hierholzer solver for the given graph.\n\n@param graph directed graph\n/",
    "identifiers": [
      "graph",
      "hierholzereulerianpath"
    ],
    "start_line": 95,
    "end_line": 97,
    "text": "public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }"
  },
  {
    "id": "16fcd83907730401accd104b87a780cbe4d76a08",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "class",
    "name": "Graph",
    "signature": "Graph",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/",
    "identifiers": [
      "add",
      "addedge",
      "adjacencylist",
      "arraylist",
      "from",
      "get",
      "getedges",
      "getnumnodes",
      "graph",
      "i",
      "integer",
      "list",
      "node",
      "numnodes",
      "size",
      "to"
    ],
    "start_line": 43,
    "end_line": 86,
    "text": "public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\n         * Constructs a graph with a given number of vertices.\n         *\n         * @param numNodes number of vertices\n         */\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\n         * Adds a directed edge from vertex {@code from} to vertex {@code to}.\n         *\n         * @param from source vertex\n         * @param to   destination vertex\n         */\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\n         * Returns a list of outgoing edges from the given vertex.\n         *\n         * @param node vertex index\n         * @return list of destination vertices\n         */\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\n         * Returns the number of vertices in the graph.\n         *\n         * @return number of vertices\n         */\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }"
  },
  {
    "id": "ac0fcba3b52020f7d387f8d140f0f62fa122204b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "getNumNodes",
    "signature": "getNumNodes()",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\nReturns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\nReturns the number of vertices in the graph.\n\n@return number of vertices\n/",
    "identifiers": [
      "adjacencylist",
      "getnumnodes",
      "size"
    ],
    "start_line": 83,
    "end_line": 85,
    "text": "public int getNumNodes() {\n            return adjacencyList.size();\n        }"
  },
  {
    "id": "b041ed132e7aaa2731dd2c3dba7e2dbba36fc2b7",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "getEdges",
    "signature": "getEdges(int node)",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\nReturns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/",
    "identifiers": [
      "adjacencylist",
      "get",
      "getedges",
      "integer",
      "list",
      "node"
    ],
    "start_line": 74,
    "end_line": 76,
    "text": "public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }"
  },
  {
    "id": "a13148357a7175accd36d202c16a4994af7540dd",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "addEdge",
    "signature": "addEdge(int from, int to)",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\nAdds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/",
    "identifiers": [
      "add",
      "addedge",
      "adjacencylist",
      "from",
      "get",
      "to"
    ],
    "start_line": 64,
    "end_line": 66,
    "text": "public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }"
  },
  {
    "id": "be2d428924df25af812066246a4b781c346dd4d4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/HierholzerEulerianPath.java",
    "kind": "constructor",
    "name": "Graph",
    "signature": "Graph(int numNodes)",
    "docstring": "Implementation of Hierholzer's Algorithm for finding an Eulerian Path or Circuit\nin a directed graph.\n\n<p>\nAn <b>Eulerian Circuit</b> is a path that starts and ends at the same vertex\nand visits every edge exactly once.\n</p>\n\n<p>\nAn <b>Eulerian Path</b> visits every edge exactly once but may start and end\nat different vertices.\n</p>\n\n<p>\n<b>Algorithm Summary:</b><br>\n1. Compute indegree and outdegree for all vertices.<br>\n2. Check if the graph satisfies Eulerian path or circuit conditions.<br>\n3. Verify that all vertices with non-zero degree are weakly connected (undirected connectivity).<br>\n4. Use Hierholzer’s algorithm to build the path by exploring unused edges iteratively.\n</p>\n\n<p>\n<b>Time Complexity:</b> O(E + V).<br>\n<b>Space Complexity:</b> O(V + E).\n</p>\n\n@author <a href=\"https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer's_algorithm\">Wikipedia: Hierholzer algorithm</a>\n/\npublic class HierholzerEulerianPath {\n\n    /**\nSimple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/",
    "identifiers": [
      "add",
      "adjacencylist",
      "arraylist",
      "graph",
      "i",
      "numnodes"
    ],
    "start_line": 51,
    "end_line": 56,
    "text": "public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }"
  },
  {
    "id": "b67f91984c919bbae36bb955c1a624e3de3bfd4b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/alignment.py",
    "kind": "function",
    "name": "remove_comments_and_docstrings",
    "signature": "remove_comments_and_docstrings(source)",
    "docstring": "",
    "identifiers": [
      "append",
      "bytesio",
      "comment",
      "decode",
      "encode",
      "indent",
      "io",
      "io_obj",
      "new_source",
      "newline",
      "output_tokens",
      "prev_toktype",
      "readline",
      "remove_comments_and_docstrings",
      "source",
      "startswith",
      "string",
      "token",
      "token_string",
      "token_type",
      "tokenerror",
      "tokenize",
      "type",
      "untokenize"
    ],
    "start_line": 62,
    "end_line": 84,
    "text": "def remove_comments_and_docstrings(source):\n\n    io_obj = io.BytesIO(source.encode('utf-8'))\n    output_tokens = []\n    prev_toktype = tokenize.INDENT\n    try:\n        for token in tokenize.tokenize(io_obj.readline):\n            token_type = token.type\n            token_string = token.string\n        \n            if token_type == tokenize.COMMENT:\n                continue\n            \n            if token_type == tokenize.STRING and prev_toktype in (tokenize.INDENT, tokenize.NEWLINE):\n                if token_string.startswith('\"\"\"') or token_string.startswith(\"'''\"):\n                    continue\n            output_tokens.append(token)\n            prev_toktype = token_type\n    except tokenize.TokenError:\n       \n        return source\n    new_source = tokenize.untokenize(output_tokens).decode('utf-8')\n    return new_source"
  },
  {
    "id": "cb369b3d837970a29f5a2470b9307242f5215b83",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/alignment.py",
    "kind": "function",
    "name": "construct_prompt",
    "signature": "construct_prompt(paper_content, files_content)",
    "docstring": "",
    "identifiers": [
      "construct_prompt",
      "content",
      "file_contents_str",
      "files_content",
      "items",
      "paper_content",
      "path",
      "prompt"
    ],
    "start_line": 40,
    "end_line": 60,
    "text": "def construct_prompt(paper_content, files_content):\n\n\n    file_contents_str = \"\"\n    for path, content in files_content.items():\n        file_contents_str += f\"file_path: {path}\\ncontent:\\n{content}\\n{'-'*60}\\n\"\n\n    prompt = f\"\"\"Please evaluate whether the following file content correctly implements the requirements outlined in the paper. In particular, carefully assess the internal implementation concerning model design, loss function design, and model updating. If any issues are found in the file content, please return the corrected complete code for the corresponding file. The output must follow the format: filename + file content, and it should be enclosed within a Python code block.\n\nPaper content:\n{'='*80}\n{paper_content}\n{'='*80}\n\nFile content:\n{'='*80}\n{file_contents_str}\n{'='*80}\n\"\"\"\n\n    return prompt"
  },
  {
    "id": "6dbd3aad6066b6d7a01b0a84b857ceb5daba31b2",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/alignment.py",
    "kind": "function",
    "name": "read_markdown_file",
    "signature": "read_markdown_file(md_file_path)",
    "docstring": "",
    "identifiers": [
      "e",
      "encoding",
      "exception",
      "f",
      "md_file_path",
      "open",
      "print",
      "read",
      "read_markdown_file"
    ],
    "start_line": 29,
    "end_line": 36,
    "text": "def read_markdown_file(md_file_path):\n\n    try:\n        with open(md_file_path, 'r', encoding='utf-8') as f:\n            return f.read()\n    except Exception as e:\n        print(f\"read file {md_file_path} error: {e}\")\n        return \"\""
  },
  {
    "id": "2da9701f1ad33fb3414f6dd78b6a357a03e57670",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/alignment.py",
    "kind": "function",
    "name": "read_files_from_dir",
    "signature": "read_files_from_dir(root_dir, extensions=(\".py\", \".json\"))",
    "docstring": "",
    "identifiers": [
      "_",
      "content",
      "dirpath",
      "e",
      "encoding",
      "endswith",
      "exception",
      "extensions",
      "f",
      "file_contents",
      "filename",
      "filenames",
      "full_path",
      "join",
      "open",
      "os",
      "path",
      "print",
      "read",
      "read_files_from_dir",
      "root_dir",
      "walk"
    ],
    "start_line": 14,
    "end_line": 27,
    "text": "def read_files_from_dir(root_dir, extensions=(\".py\", \".json\")):\n\n    file_contents = {}\n    for dirpath, _, filenames in os.walk(root_dir):\n        for filename in filenames:\n            if filename.endswith(extensions):\n                full_path = os.path.join(dirpath, filename)\n                try:\n                    with open(full_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                    file_contents[full_path] = content\n                except Exception as e:\n                    print(f\"read file {full_path} error: {e}\")\n    return file_contents"
  },
  {
    "id": "597111455a50c9077720d10f7ac37b06eff20e4f",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/alignment.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 9,
    "end_line": 12,
    "text": "def write_file(file_path, content):\n\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "7f2805fb13519b5bf45ddaf0c2c9197bf1cb04f8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_fix.py",
    "kind": "function",
    "name": "run_fix_script",
    "signature": "run_fix_script(code_str, script_path=\"test.py\")",
    "docstring": "",
    "identifiers": [
      "code_str",
      "communicate",
      "cwd",
      "pipe",
      "popen",
      "process",
      "returncode",
      "run_fix_script",
      "script_path",
      "stderr",
      "stdout",
      "subprocess",
      "text",
      "write_file"
    ],
    "start_line": 41,
    "end_line": 52,
    "text": "def run_fix_script(code_str, script_path=\"test.py\"):\n    # Function to write fix code to a temporary file and run it via subprocess\n    write_file(script_path, code_str)\n    process = subprocess.Popen(\n        [\"python\", script_path],\n        cwd=\"iter_code/paper/code_generate\",\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n    stdout, stderr = process.communicate()\n    return stdout, stderr, process.returncode"
  },
  {
    "id": "b25d21e3b3fb8896191fd788a1af0d635c713f7d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_fix.py",
    "kind": "function",
    "name": "run_main_py",
    "signature": "run_main_py(target_directory)",
    "docstring": "",
    "identifiers": [
      "communicate",
      "copy",
      "cwd",
      "env",
      "environ",
      "os",
      "pipe",
      "popen",
      "process",
      "returncode",
      "run_main_py",
      "stderr",
      "stdout",
      "subprocess",
      "target_directory",
      "text"
    ],
    "start_line": 26,
    "end_line": 39,
    "text": "def run_main_py(target_directory):\n    # Function to run main.py in the specified directory using CUDA device 2\n    env = os.environ.copy()\n    env[\"CUDA_VISIBLE_DEVICES\"] = \"2\"\n    process = subprocess.Popen(\n        [\"python\", \"main.py\"],\n        cwd=target_directory,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n        env=env\n    )\n    stdout, stderr = process.communicate()\n    return stdout, stderr, process.returncode"
  },
  {
    "id": "73d22bda70eb59b5a546d8b60b1aab7f307d019d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_fix.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(response)",
    "docstring": "",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "re",
      "response",
      "search",
      "strip"
    ],
    "start_line": 18,
    "end_line": 24,
    "text": "def extract_python_code(response):\n    # Function to extract Python code between ```python``` code blocks\n    match = re.search(r'```python\\n(.*?)\\n```', response, re.DOTALL)\n    if match:\n        return match.group(1).strip()\n    else:\n        return None"
  },
  {
    "id": "d5d1f268ea046f8a1a108b968e8bd90832eb9f63",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_fix.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 13,
    "end_line": 16,
    "text": "def write_file(file_path, content):\n    # Function to write content to a file with UTF-8 encoding\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "6bdcf02ad4f3f12a52a4c60b977e53fef944fd93",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_fix.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(file_path)",
    "docstring": "",
    "identifiers": [
      "encoding",
      "file",
      "file_path",
      "open",
      "read",
      "read_file"
    ],
    "start_line": 8,
    "end_line": 11,
    "text": "def read_file(file_path):\n    # Function to read file content with UTF-8 encoding\n    with open(file_path, 'r', encoding='utf-8') as file:\n        return file.read()"
  },
  {
    "id": "377216b7d5415ca6fe75e3d63ecb086060ae1929",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "process_files",
    "signature": "process_files(merged_json_path, paper_path, prompt_file_path, output_directory)",
    "docstring": "",
    "identifiers": [
      "copy",
      "dict",
      "dumps",
      "encoding",
      "ensure_ascii",
      "extract_python_code",
      "f",
      "file_design_content",
      "generate_prompt",
      "indent",
      "isinstance",
      "items",
      "join",
      "json",
      "key",
      "load",
      "merged_data",
      "merged_data_copy",
      "merged_data_str",
      "merged_json_path",
      "open",
      "os",
      "output_directory",
      "output_file_path",
      "paper_content",
      "paper_path",
      "path",
      "print",
      "process_files",
      "prompt",
      "prompt_file_path",
      "prompt_template",
      "python_code",
      "python_file_content",
      "read_file",
      "response",
      "save_generated_code",
      "send_to_model",
      "write_file"
    ],
    "start_line": 58,
    "end_line": 106,
    "text": "def process_files(merged_json_path, paper_path, prompt_file_path, output_directory):\n\n    paper_content = read_file(paper_path)\n    \n\n    prompt_template = read_file(prompt_file_path)\n\n\n    with open(merged_json_path, 'r', encoding='utf-8') as f:\n        merged_data = json.load(f)\n\n    merged_data_copy = merged_data.copy()\n\n\n    for key, file_design_content in merged_data.items():\n\n        if not isinstance(file_design_content, dict) or \"file_name\" not in file_design_content:\n            print(f\"Skipping {key} because 'file_name' field not found or content is not a dict.\")\n            continue\n\n\n        output_file_path = os.path.join(output_directory, file_design_content[\"file_name\"])\n\n\n        python_file_content = json.dumps(file_design_content, ensure_ascii=False, indent=4)\n        merged_data_str = json.dumps(merged_data_copy, ensure_ascii=False, indent=4)\n        \n        prompt = generate_prompt(prompt_template, paper_content, python_file_content, merged_data_str)\n        \n        write_file(\"/home/lzj/code_for_run/paper2code/test.py\", prompt)\n\n        \n        response = send_to_model(prompt)\n\n        if response:\n           \n            python_code = extract_python_code(response)\n\n            if python_code:\n                \n                save_generated_code(output_file_path, python_code)\n                print(f\"Response for {key} saved to {output_file_path}\")\n                \n                \n                merged_data_copy[key] = python_code\n            else:\n                print(f\"No Python code found in the response for {key}\")\n        else:\n            print(f\"Error processing {key}\")"
  },
  {
    "id": "edd65ba589a8985ee43f8dc861a43e6ec22bb130",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(response)",
    "docstring": "",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "re",
      "response",
      "search",
      "strip"
    ],
    "start_line": 50,
    "end_line": 56,
    "text": "def extract_python_code(response):\n\n    match = re.search(r'```python\\n(.*?)\\n```', response, re.DOTALL)\n    if match:\n        return match.group(1).strip()  \n    else:\n        return None"
  },
  {
    "id": "516b8cc7d2dfbd10d381c1454b4f52cef5ca2dcf",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "generate_prompt",
    "signature": "generate_prompt(prompt_template, paper_content, python_file_content, whole_design)",
    "docstring": "",
    "identifiers": [
      "generate_prompt",
      "paper_content",
      "prompt",
      "prompt_template",
      "python_file_content",
      "replace",
      "whole_design"
    ],
    "start_line": 43,
    "end_line": 48,
    "text": "def generate_prompt(prompt_template, paper_content, python_file_content, whole_design):\n\n    prompt = prompt_template.replace(\"{paper_content}\", paper_content)\n    prompt = prompt.replace(\"{python_file_content}\", python_file_content)\n    prompt = prompt.replace(\"{whole_design}\", whole_design)\n    return prompt"
  },
  {
    "id": "7d4bb55c1fd285a57235bfec24147467349e1aa6",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "send_to_model",
    "signature": "send_to_model(prompt)",
    "docstring": "",
    "identifiers": [
      "chatcompletion",
      "completion_tokens",
      "create",
      "e",
      "exception",
      "max_completion_tokens",
      "messages",
      "model",
      "openai",
      "print",
      "prompt",
      "prompt_tokens",
      "response",
      "send_to_model",
      "total_tokens",
      "usage_info"
    ],
    "start_line": 20,
    "end_line": 41,
    "text": "def send_to_model(prompt):\n    messages = [\n        {\"role\": \"user\", \"content\": \"You are a Python code implementation expert.\\n\\n\" + prompt}\n    ]\n    \n    try:\n\n        response = openai.ChatCompletion.create(\n            model=\"o1-mini\",  # 或 \"o1-mini\"\n            messages=messages,\n            max_completion_tokens=8000\n        )\n \n        usage_info = response['usage']\n        prompt_tokens = usage_info['prompt_tokens']\n        completion_tokens = usage_info['completion_tokens']\n        total_tokens = usage_info['total_tokens']\n        print(f\"Prompt tokens: {prompt_tokens}, Completion tokens: {completion_tokens}, Total tokens: {total_tokens}\")\n        return response['choices'][0]['message']['content']\n    except Exception as e:\n        print(f\"Error calling OpenAI API: {e}\")\n        return None"
  },
  {
    "id": "f061a358eace456d3704ca72b78e83c01706659e",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "save_generated_code",
    "signature": "save_generated_code(file_path, code)",
    "docstring": "",
    "identifiers": [
      "code",
      "dirname",
      "encoding",
      "exist_ok",
      "file",
      "file_path",
      "makedirs",
      "open",
      "os",
      "path",
      "save_generated_code",
      "write"
    ],
    "start_line": 14,
    "end_line": 18,
    "text": "def save_generated_code(file_path, code):\n\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(code)"
  },
  {
    "id": "246201599392d0e649a953fcb9c24c8e1cd525c4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 10,
    "end_line": 12,
    "text": "def write_file(file_path, content):\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "a0a84b07f1e62e9ff8235b87ce83a5b95582d77b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/code_generate.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(file_path)",
    "docstring": "",
    "identifiers": [
      "encoding",
      "file",
      "file_path",
      "open",
      "read",
      "read_file"
    ],
    "start_line": 6,
    "end_line": 8,
    "text": "def read_file(file_path):\n    with open(file_path, 'r', encoding='utf-8') as file:\n        return file.read()"
  },
  {
    "id": "a37c90c0b1bf496d08c19de5ca10f36b2ea3e3a8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "class",
    "name": "BufferGeometry",
    "signature": "BufferGeometry",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher",
    "identifiers": [
      "_box",
      "_boxmorphtargets",
      "_id",
      "_m1",
      "_obj",
      "_offset",
      "_vector",
      "a",
      "ab",
      "add",
      "addgroup",
      "addscaledvector",
      "addvectors",
      "angle",
      "applymatrix4",
      "applynormalmatrix",
      "applyquaternion",
      "array",
      "array2",
      "arrayneedsuint32",
      "attribute",
      "attributearray",
      "attributes",
      "b",
      "boundingbox",
      "boundingsphere",
      "box3",
      "bufferattribute",
      "buffergeometry",
      "c",
      "call",
      "cb",
      "center",
      "cleargroups",
      "clone",
      "computeboundingbox",
      "computeboundingsphere",
      "computetangents",
      "computevertexnormals",
      "constructor",
      "convertbufferattribute",
      "copy",
      "count",
      "cross",
      "crossvectors",
      "data",
      "defineproperty",
      "deleteattribute",
      "dispatchevent",
      "dispose",
      "distancetosquared",
      "dot",
      "drawrange",
      "error",
      "eventdispatcher",
      "expandbypoint",
      "float32array",
      "float32bufferattribute",
      "frombufferattribute",
      "generateuuid",
      "generator",
      "geometry2",
      "getattribute",
      "getcenter",
      "getindex",
      "getindirect",
      "getnormalmatrix",
      "getx",
      "group",
      "groups",
      "handletriangle",
      "handlevertex",
      "hasattribute",
      "hasmorphattributes",
      "i",
      "il",
      "index",
      "index2",
      "indices",
      "indirect",
      "infinity",
      "isarray",
      "isbuffergeometry",
      "isfinite",
      "isglbufferattribute",
      "isinterleavedbufferattribute",
      "isnan",
      "itemsize",
      "j",
      "jl",
      "json",
      "key",
      "keys",
      "l",
      "length",
      "lookat",
      "makeempty",
      "makerotationfromquaternion",
      "makerotationx",
      "makerotationy",
      "makerotationz",
      "makescale",
      "maketranslation",
      "materialindex",
      "math",
      "matrix",
      "matrix3",
      "max",
      "maxradiussq",
      "metadata",
      "min",
      "morpharray",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "multiplyscalar",
      "n",
      "n2",
      "na",
      "name",
      "nb",
      "nc",
      "needsupdate",
      "negate",
      "newattribute",
      "normal",
      "normalattribute",
      "normalize",
      "normalized",
      "normalizenormals",
      "normalmatrix",
      "normals",
      "object",
      "offset",
      "pa",
      "parameters",
      "parse",
      "pb",
      "pc",
      "point",
      "points",
      "position",
      "positionattribute",
      "prototype",
      "push",
      "q",
      "r",
      "radius",
      "rotatex",
      "rotatey",
      "rotatez",
      "scale",
      "sdir",
      "set",
      "setattribute",
      "setdrawrange",
      "setfrombufferattribute",
      "setfrompoints",
      "setindex",
      "setindirect",
      "setxyz",
      "setxyzw",
      "slice",
      "source",
      "sphere",
      "sqrt",
      "start",
      "stride",
      "stringify",
      "sub",
      "subvectors",
      "t",
      "tan1",
      "tan2",
      "tangent",
      "tangentattribute",
      "tdir",
      "test",
      "tmp",
      "tmp2",
      "tojson",
      "tononindexed",
      "transformdirection",
      "translate",
      "type",
      "uint16bufferattribute",
      "uint32bufferattribute",
      "updatematrix",
      "userdata",
      "uuid",
      "uv",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "v",
      "va",
      "value",
      "vb",
      "vc",
      "vector",
      "vector2",
      "vector3",
      "version",
      "w",
      "warn",
      "x",
      "y",
      "z"
    ],
    "start_line": 48,
    "end_line": 1444,
    "text": "class BufferGeometry extends EventDispatcher {\n\n\t/**\n\t * Constructs a new geometry.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\n\t\t * The ID of the geometry.\n\t\t *\n\t\t * @name BufferGeometry#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The UUID of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\n\t\t * Allows for vertices to be re-used across multiple triangles; this is\n\t\t * called using \"indexed triangles\". Each triangle is associated with the\n\t\t * indices of three vertices. This attribute therefore stores the index of\n\t\t * each vertex for each triangular face. If this attribute is not set, the\n\t\t * renderer assumes that each three contiguous positions represent a single triangle.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.index = null;\n\n\t\t/**\n\t\t * A (storage) buffer attribute which was generated with a compute shader and\n\t\t * now defines indirect draw calls.\n\t\t *\n\t\t * Can only be used with {@link WebGPURenderer} and a WebGPU backend.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.indirect = null;\n\n\t\t/**\n\t\t * This dictionary has as id the name of the attribute to be set and as value\n\t\t * the buffer attribute to set it to. Rather than accessing this property directly,\n\t\t * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\t\t *\n\t\t * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n\t\t */\n\t\tthis.attributes = {};\n\n\t\t/**\n\t\t * This dictionary holds the morph targets of the geometry.\n\t\t *\n\t\t * Note: Once the geometry has been rendered, the morph attribute data cannot\n\t\t * be changed. You will have to call `dispose()?, and create a new geometry instance.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.morphAttributes = {};\n\n\t\t/**\n\t\t * Used to control the morph target behavior; when set to `true`, the morph\n\t\t * target data is treated as relative offsets, rather than as absolute\n\t\t * positions/normals.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\n\t\t * Split the geometry into groups, each of which will be rendered in a\n\t\t * separate draw call. This allows an array of materials to be used with the geometry.\n\t\t *\n\t\t * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\t\t *\n\t\t * Every vertex and index must belong to exactly one group — groups must not share vertices or\n\t\t * indices, and must not leave vertices or indices unused.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.groups = [];\n\n\t\t/**\n\t\t * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Determines the part of the geometry to render. This should not be set directly,\n\t\t * instead use `setDrawRange()`.\n\t\t *\n\t\t * @type {{start:number,count:number}}\n\t\t */\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the geometry.\n\t\t * It should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\n\t * Returns the index of this geometry.\n\t *\n\t * @return {?BufferAttribute} The index. Returns `null` if no index is defined.\n\t */\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\n\t * Sets the given index to this geometry.\n\t *\n\t * @param {Array<number>|BufferAttribute} index - The index to set.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the given indirect attribute to this geometry.\n\t *\n\t * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the indirect attribute of this geometry.\n\t *\n\t * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n\t */\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\n\t * Returns the buffer attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\n\t * Returns `undefined` if not attribute has been found.\n\t */\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\n\t * Sets the given attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes the attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name to delete.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if this geometry has an attribute for the given name.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {boolean} Whether this geometry has an attribute for the given name or not.\n\t */\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\n\t * Adds a group to this geometry.\n\t *\n\t * @param {number} start - The first element in this draw call. That is the first\n\t * vertex for non-indexed geometry, otherwise the first triangle index.\n\t * @param {number} count - Specifies how many vertices (or indices) are part of this group.\n\t * @param {number} [materialIndex=0] - The material array index to use.\n\t */\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Clears all groups.\n\t */\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\n\t * Sets the draw range for this geometry.\n\t *\n\t * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n\t * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\n\t * For indexed BufferGeometry, `count` is the number of indices to render.\n\t */\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\n\t * Applies the given 4x4 transformation matrix to the geometry.\n\t *\n\t * @param {Matrix4} matrix - The matrix to apply.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Applies the rotation represented by the Quaternion to the geometry.\n\t *\n\t * @param {Quaternion} q - The Quaternion to apply.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the X axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the Y axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry about the Z axis. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#rotation} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} angle - The angle in radians.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Translates the geometry. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#position} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} x - The x offset.\n\t * @param {number} y - The y offset.\n\t * @param {number} z - The z offset.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Scales the geometry. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#scale} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {number} x - The x scale.\n\t * @param {number} y - The y scale.\n\t * @param {number} z - The z scale.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Rotates the geometry to face a point in 3D space. This is typically done as a one time\n\t * operation, and not during a loop. Use {@link Object3D#lookAt} for typical\n\t * real-time mesh rotation.\n\t *\n\t * @param {Vector3} vector - The target point.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Center the geometry based on its bounding box.\n\t *\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines a geometry by creating a `position` attribute based on the given array of points. The array\n\t * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\n\t * set to `0`.\n\t *\n\t * If the method is used with an existing `position` attribute, the vertex data are overwritten with the\n\t * data from the array. The length of the array must match the vertex count.\n\t *\n\t * @param {Array<Vector2>|Array<Vector3>} points - The points.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the bounding box of the geometry, and updates the `boundingBox` member.\n\t * The bounding box is not computed by the engine; it must be computed by your app.\n\t * You may need to recompute the bounding box if the geometry vertices are modified.\n\t */\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.\n\t * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\n\t * You may need to recompute the bounding sphere if the geometry vertices are modified.\n\t */\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calculates and adds a tangent attribute to this geometry.\n\t *\n\t * The computation is only supported for indexed geometries and if position, normal, and uv attributes\n\t * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n\t * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n\t */\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes vertex normals for the given vertex data. For indexed geometries, the method sets\n\t * each vertex normal to be the average of the face normals of the faces that share that vertex.\n\t * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal\n\t * to be the same as the face normal.\n\t */\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Ensures every normal vector in a geometry will have a magnitude of `1`. This will\n\t * correct lighting on the geometry surfaces.\n\t */\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Return a new non-index version of this indexed geometry. If the geometry\n\t * is already non-indexed, the method is a NOOP.\n\t *\n\t * @return {BufferGeometry} The non-indexed version of this indexed geometry.\n\t */\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\n\t * Serializes the geometry into JSON.\n\t *\n\t * @return {Object} A JSON object representing the serialized geometry.\n\t */\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns a new geometry with copied values from this instance.\n\t *\n\t * @return {BufferGeometry} A clone of this instance.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Copies the values of the given geometry to this instance.\n\t *\n\t * @param {BufferGeometry} source - The geometry to copy.\n\t * @return {BufferGeometry} A reference to this instance.\n\t */\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t *\n\t * @fires BufferGeometry#dispose\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}"
  },
  {
    "id": "66fec1bc5afdabc4cbc86158bbb0ba8fd6afe4da",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "dispose",
    "signature": "dispose()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\nReturn a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\nSerializes the geometry into JSON.\n\n@return {Object} A JSON object representing the serialized geometry.\n/\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\nReturns a new geometry with copied values from this instance.\n\n@return {BufferGeometry} A clone of this instance.\n/\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\nCopies the values of the given geometry to this instance.\n\n@param {BufferGeometry} source - The geometry to copy.\n@return {BufferGeometry} A reference to this instance.\n/\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nFrees the GPU-related resources allocated by this instance. Call this\nmethod whenever this instance is no longer used in your app.\n\n@fires BufferGeometry#dispose\n/",
    "identifiers": [
      "dispatchevent",
      "dispose",
      "type"
    ],
    "start_line": 1438,
    "end_line": 1442,
    "text": "dispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}"
  },
  {
    "id": "c8e58f9974aaaafa1f96eee2dfb10a49b6e0d669",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "copy",
    "signature": "copy( source )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\nReturn a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\nSerializes the geometry into JSON.\n\n@return {Object} A JSON object representing the serialized geometry.\n/\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\nReturns a new geometry with copied values from this instance.\n\n@return {BufferGeometry} A clone of this instance.\n/\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\nCopies the values of the given geometry to this instance.\n\n@param {BufferGeometry} source - The geometry to copy.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "addgroup",
      "array",
      "attribute",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "clone",
      "copy",
      "count",
      "data",
      "drawrange",
      "group",
      "groups",
      "i",
      "index",
      "l",
      "length",
      "materialindex",
      "morphattribute",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "push",
      "setattribute",
      "setindex",
      "source",
      "start",
      "userdata"
    ],
    "start_line": 1327,
    "end_line": 1430,
    "text": "copy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "ca4c27eb5c37ffa4af0e34e88dc2a120f9f4176b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "clone",
    "signature": "clone()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\nReturn a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\nSerializes the geometry into JSON.\n\n@return {Object} A JSON object representing the serialized geometry.\n/\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\nReturns a new geometry with copied values from this instance.\n\n@return {BufferGeometry} A clone of this instance.\n/",
    "identifiers": [
      "clone",
      "constructor",
      "copy"
    ],
    "start_line": 1315,
    "end_line": 1319,
    "text": "clone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}"
  },
  {
    "id": "ef5f86367348bfcbf57a45e60d253595ffb2e211",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "toJSON",
    "signature": "toJSON()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\nReturn a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\t/**\nSerializes the geometry into JSON.\n\n@return {Object} A JSON object representing the serialized geometry.\n/",
    "identifiers": [
      "array",
      "attribute",
      "attributearray",
      "attributes",
      "boundingsphere",
      "call",
      "constructor",
      "data",
      "generator",
      "groups",
      "hasmorphattributes",
      "i",
      "il",
      "index",
      "json",
      "key",
      "keys",
      "length",
      "metadata",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "object",
      "parameters",
      "parse",
      "prototype",
      "push",
      "slice",
      "stringify",
      "tojson",
      "type",
      "userdata",
      "uuid",
      "version"
    ],
    "start_line": 1200,
    "end_line": 1308,
    "text": "toJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}"
  },
  {
    "id": "2b97f523c206cac725895ec07f39c08df03b139b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "toNonIndexed",
    "signature": "toNonIndexed()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\t/**\nReturn a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/",
    "identifiers": [
      "addgroup",
      "array",
      "array2",
      "attribute",
      "attributes",
      "bufferattribute",
      "buffergeometry",
      "constructor",
      "convertbufferattribute",
      "count",
      "data",
      "geometry2",
      "group",
      "groups",
      "i",
      "il",
      "index",
      "index2",
      "indices",
      "isinterleavedbufferattribute",
      "itemsize",
      "j",
      "l",
      "length",
      "materialindex",
      "morpharray",
      "morphattribute",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "newattribute",
      "normalized",
      "offset",
      "push",
      "setattribute",
      "start",
      "stride",
      "tononindexed",
      "warn"
    ],
    "start_line": 1093,
    "end_line": 1193,
    "text": "toNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}"
  },
  {
    "id": "2075ee78bde0f78cc5b2ece63a95b5c04b7fa2f3",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "function",
    "name": "convertBufferAttribute",
    "signature": "convertBufferAttribute( attribute, indices )",
    "docstring": "rotate geometry around world x-axis",
    "identifiers": [
      "array",
      "array2",
      "attribute",
      "bufferattribute",
      "constructor",
      "convertbufferattribute",
      "data",
      "i",
      "index",
      "index2",
      "indices",
      "isinterleavedbufferattribute",
      "itemsize",
      "j",
      "l",
      "length",
      "normalized",
      "offset",
      "stride"
    ],
    "start_line": 1095,
    "end_line": 1127,
    "text": "function convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}"
  },
  {
    "id": "90507e2fbdfe3da596133c95be0a149962621632",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "normalizeNormals",
    "signature": "normalizeNormals()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\nEnsures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/",
    "identifiers": [
      "_vector",
      "attributes",
      "count",
      "frombufferattribute",
      "i",
      "il",
      "normal",
      "normalize",
      "normalizenormals",
      "normals",
      "setxyz",
      "x",
      "y",
      "z"
    ],
    "start_line": 1071,
    "end_line": 1085,
    "text": "normalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}"
  },
  {
    "id": "0a1751d4a89639d078afa172b1d0edded32681c1",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "computeVertexNormals",
    "signature": "computeVertexNormals()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nComputes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/",
    "identifiers": [
      "ab",
      "add",
      "bufferattribute",
      "cb",
      "computevertexnormals",
      "count",
      "cross",
      "float32array",
      "frombufferattribute",
      "getattribute",
      "getx",
      "i",
      "il",
      "index",
      "na",
      "nb",
      "nc",
      "needsupdate",
      "normalattribute",
      "normalizenormals",
      "pa",
      "pb",
      "pc",
      "positionattribute",
      "setattribute",
      "setxyz",
      "subvectors",
      "va",
      "vb",
      "vc",
      "vector3",
      "x",
      "y",
      "z"
    ],
    "start_line": 975,
    "end_line": 1065,
    "text": "computeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}"
  },
  {
    "id": "25cc24c60794f7bedc9571599309a9391ae6aff7",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "computeTangents",
    "signature": "computeTangents()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\nCalculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/",
    "identifiers": [
      "a",
      "add",
      "addscaledvector",
      "attributes",
      "b",
      "bufferattribute",
      "c",
      "computetangents",
      "copy",
      "count",
      "crossvectors",
      "dot",
      "error",
      "float32array",
      "frombufferattribute",
      "getattribute",
      "getx",
      "group",
      "groups",
      "handletriangle",
      "handlevertex",
      "hasattribute",
      "i",
      "il",
      "index",
      "isfinite",
      "j",
      "jl",
      "length",
      "multiplyscalar",
      "n",
      "n2",
      "normal",
      "normalattribute",
      "normalize",
      "position",
      "positionattribute",
      "r",
      "sdir",
      "setattribute",
      "setxyzw",
      "start",
      "sub",
      "t",
      "tan1",
      "tan2",
      "tangentattribute",
      "tdir",
      "test",
      "tmp",
      "tmp2",
      "uv",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "v",
      "va",
      "vb",
      "vc",
      "vector2",
      "vector3",
      "w",
      "x",
      "y",
      "z"
    ],
    "start_line": 810,
    "end_line": 967,
    "text": "computeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}"
  },
  {
    "id": "925806020b32581514468d24b729f0f396b06f00",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "function",
    "name": "handleVertex",
    "signature": "handleVertex( v )",
    "docstring": "rotate geometry around world x-axis",
    "identifiers": [
      "copy",
      "crossvectors",
      "dot",
      "frombufferattribute",
      "handlevertex",
      "multiplyscalar",
      "n",
      "n2",
      "normalattribute",
      "normalize",
      "setxyzw",
      "sub",
      "t",
      "tan1",
      "tan2",
      "tangentattribute",
      "test",
      "tmp",
      "tmp2",
      "v",
      "w",
      "x",
      "y",
      "z"
    ],
    "start_line": 928,
    "end_line": 948,
    "text": "function handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}"
  },
  {
    "id": "e64136f1345bd7fb1ba4aa5a1c85c128c6b511a4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "function",
    "name": "handleTriangle",
    "signature": "handleTriangle( a, b, c )",
    "docstring": "rotate geometry around world x-axis",
    "identifiers": [
      "a",
      "add",
      "addscaledvector",
      "b",
      "c",
      "copy",
      "frombufferattribute",
      "handletriangle",
      "isfinite",
      "multiplyscalar",
      "positionattribute",
      "r",
      "sdir",
      "sub",
      "tan1",
      "tan2",
      "tdir",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "va",
      "vb",
      "vc",
      "x",
      "y"
    ],
    "start_line": 860,
    "end_line": 893,
    "text": "function handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}"
  },
  {
    "id": "623c61d1039394c856410f5cd67a7d5bed2bcfd9",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "computeBoundingSphere",
    "signature": "computeBoundingSphere()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\t/**\nComputes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/",
    "identifiers": [
      "_box",
      "_boxmorphtargets",
      "_offset",
      "_vector",
      "add",
      "addvectors",
      "attributes",
      "boundingsphere",
      "center",
      "computeboundingsphere",
      "count",
      "distancetosquared",
      "error",
      "expandbypoint",
      "frombufferattribute",
      "getcenter",
      "i",
      "il",
      "infinity",
      "isglbufferattribute",
      "isnan",
      "j",
      "jl",
      "length",
      "math",
      "max",
      "maxradiussq",
      "min",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "position",
      "radius",
      "set",
      "setfrombufferattribute",
      "sphere",
      "sqrt",
      "vector3"
    ],
    "start_line": 691,
    "end_line": 801,
    "text": "computeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}"
  },
  {
    "id": "a2632e251acaa6edbfad4e5dd613fb3d8783ccd0",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "computeBoundingBox",
    "signature": "computeBoundingBox()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nComputes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/",
    "identifiers": [
      "_box",
      "_vector",
      "addvectors",
      "attributes",
      "boundingbox",
      "box3",
      "computeboundingbox",
      "error",
      "expandbypoint",
      "i",
      "il",
      "infinity",
      "isglbufferattribute",
      "isnan",
      "length",
      "makeempty",
      "max",
      "min",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "position",
      "set",
      "setfrombufferattribute",
      "vector3",
      "x",
      "y",
      "z"
    ],
    "start_line": 616,
    "end_line": 684,
    "text": "computeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}"
  },
  {
    "id": "ae1f29d01d4e8541d894d8c83b86805ee0ea5c69",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "setFromPoints",
    "signature": "setFromPoints( points )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDefines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "count",
      "float32bufferattribute",
      "getattribute",
      "i",
      "l",
      "length",
      "math",
      "min",
      "needsupdate",
      "point",
      "points",
      "position",
      "positionattribute",
      "push",
      "setattribute",
      "setfrompoints",
      "setxyz",
      "warn",
      "x",
      "y",
      "z"
    ],
    "start_line": 569,
    "end_line": 609,
    "text": "setFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "5b7eea725ca1bb71c3b1703e1f45d53b727e05a3",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "center",
    "signature": "center()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nCenter the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_offset",
      "boundingbox",
      "center",
      "computeboundingbox",
      "getcenter",
      "negate",
      "translate",
      "x",
      "y",
      "z"
    ],
    "start_line": 546,
    "end_line": 556,
    "text": "center() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "e745a8af8fdf5697e9eb8a0b6f361e07552c7c1b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "lookAt",
    "signature": "lookAt( vector )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_obj",
      "applymatrix4",
      "lookat",
      "matrix",
      "updatematrix",
      "vector"
    ],
    "start_line": 529,
    "end_line": 539,
    "text": "lookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "ffd1008fe542d72d47e3a76148c8c2a58d96fe68",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "scale",
    "signature": "scale( x, y, z )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nScales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "makescale",
      "scale",
      "x",
      "y",
      "z"
    ],
    "start_line": 509,
    "end_line": 519,
    "text": "scale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "70a4774a29c8685f3ede4feef45652dd79466c4c",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "translate",
    "signature": "translate( x, y, z )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nTranslates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "maketranslation",
      "translate",
      "x",
      "y",
      "z"
    ],
    "start_line": 487,
    "end_line": 497,
    "text": "translate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "9ba1616d5c2a96f674699aabfbee6e566ddaa527",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "rotateZ",
    "signature": "rotateZ( angle )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationz",
      "rotatez"
    ],
    "start_line": 465,
    "end_line": 475,
    "text": "rotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "d5f22db1b485a1c8eb2ebecdeb6612ed2e573830",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "rotateY",
    "signature": "rotateY( angle )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationy",
      "rotatey"
    ],
    "start_line": 445,
    "end_line": 455,
    "text": "rotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "2afe07adbfacb705924331caadf0521f83338a64",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "rotateX",
    "signature": "rotateX( angle )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\nRotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationx",
      "rotatex"
    ],
    "start_line": 425,
    "end_line": 435,
    "text": "rotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "5b827590e78418ed650122234c7be8b13a283894",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "applyQuaternion",
    "signature": "applyQuaternion( q )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nApplies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "applyquaternion",
      "makerotationfromquaternion",
      "q"
    ],
    "start_line": 407,
    "end_line": 415,
    "text": "applyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "6353803daba1aeb76478d8e7cd7f09e606380bea",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "applyMatrix4",
    "signature": "applyMatrix4( matrix )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\t/**\nApplies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "applymatrix4",
      "applynormalmatrix",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "computeboundingbox",
      "computeboundingsphere",
      "getnormalmatrix",
      "matrix",
      "matrix3",
      "needsupdate",
      "normal",
      "normalmatrix",
      "position",
      "tangent",
      "transformdirection"
    ],
    "start_line": 351,
    "end_line": 399,
    "text": "applyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "e293b77c8f41bd779e5b66c351c0d5cab24778eb",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "setDrawRange",
    "signature": "setDrawRange( start, count )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\t/**\nSets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/",
    "identifiers": [
      "count",
      "drawrange",
      "setdrawrange",
      "start"
    ],
    "start_line": 338,
    "end_line": 343,
    "text": "setDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}"
  },
  {
    "id": "a582bd1f5f7ec1a86fbc57660ea74a35289ca777",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "clearGroups",
    "signature": "clearGroups()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\t/**\nClears all groups.\n/",
    "identifiers": [
      "cleargroups",
      "groups"
    ],
    "start_line": 325,
    "end_line": 329,
    "text": "clearGroups() {\n\n\t\tthis.groups = [];\n\n\t}"
  },
  {
    "id": "311f1e37a873e36803d34014e2229a8699fbe044",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "addGroup",
    "signature": "addGroup( start, count, materialIndex = 0 )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\t/**\nAdds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/",
    "identifiers": [
      "addgroup",
      "count",
      "groups",
      "materialindex",
      "push",
      "start"
    ],
    "start_line": 310,
    "end_line": 320,
    "text": "addGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}"
  },
  {
    "id": "d89bf94088b13a089bf021503593b43afa9e9761",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "hasAttribute",
    "signature": "hasAttribute( name )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/",
    "identifiers": [
      "attributes",
      "hasattribute",
      "name"
    ],
    "start_line": 296,
    "end_line": 300,
    "text": "hasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}"
  },
  {
    "id": "644b316310560e3d237059c6b0a0833da6a3b10e",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "deleteAttribute",
    "signature": "deleteAttribute( name )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nDeletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "attributes",
      "deleteattribute",
      "name"
    ],
    "start_line": 282,
    "end_line": 288,
    "text": "deleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "7f938da4f1b4ee7cb073f9b338e7aecf97201e99",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "setAttribute",
    "signature": "setAttribute( name, attribute )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\t/**\nSets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "attribute",
      "attributes",
      "name",
      "setattribute"
    ],
    "start_line": 268,
    "end_line": 274,
    "text": "setAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "4b606a6ab2d8683ba910a0bec2306b239cf2e36d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "getAttribute",
    "signature": "getAttribute( name )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\t/**\nReturns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/",
    "identifiers": [
      "attributes",
      "getattribute",
      "name"
    ],
    "start_line": 255,
    "end_line": 259,
    "text": "getAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}"
  },
  {
    "id": "90d115ffc797c2c2f5f4b14acdf60eb9696222c4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "getIndirect",
    "signature": "getIndirect()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\t/**\nReturns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/",
    "identifiers": [
      "getindirect",
      "indirect"
    ],
    "start_line": 242,
    "end_line": 246,
    "text": "getIndirect() {\n\n\t\treturn this.indirect;\n\n\t}"
  },
  {
    "id": "12c66a36105e3a03d54a84eb8361314b7b5f0bdb",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "setIndirect",
    "signature": "setIndirect( indirect )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\nSets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "indirect",
      "setindirect"
    ],
    "start_line": 229,
    "end_line": 235,
    "text": "setIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "59054ef791adb2f11a6dcfb7e3aed3f048e7fd5d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "setIndex",
    "signature": "setIndex( index )",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\nSets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "array",
      "arrayneedsuint32",
      "index",
      "isarray",
      "setindex",
      "uint16bufferattribute",
      "uint32bufferattribute"
    ],
    "start_line": 207,
    "end_line": 221,
    "text": "setIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "dd9fe37d20904b65dd623779c2f387db201668c1",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "getIndex",
    "signature": "getIndex()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\nThis flag can be used for type testing.\n\n@type {boolean}\n@readonly\n@default true\n/\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\nThe ID of the geometry.\n\n@name BufferGeometry#id\n@type {number}\n@readonly\n/\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\nThe UUID of the geometry.\n\n@type {string}\n@readonly\n/\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\nThe name of the geometry.\n\n@type {string}\n/\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\nAllows for vertices to be re-used across multiple triangles; this is\ncalled using \"indexed triangles\". Each triangle is associated with the\nindices of three vertices. This attribute therefore stores the index of\neach vertex for each triangular face. If this attribute is not set, the\nrenderer assumes that each three contiguous positions represent a single triangle.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.index = null;\n\n\t\t/**\nA (storage) buffer attribute which was generated with a compute shader and\nnow defines indirect draw calls.\n\nCan only be used with {@link WebGPURenderer} and a WebGPU backend.\n\n@type {?BufferAttribute}\n@default null\n/\n\t\tthis.indirect = null;\n\n\t\t/**\nThis dictionary has as id the name of the attribute to be set and as value\nthe buffer attribute to set it to. Rather than accessing this property directly,\nuse `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\n@type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n/\n\t\tthis.attributes = {};\n\n\t\t/**\nThis dictionary holds the morph targets of the geometry.\n\nNote: Once the geometry has been rendered, the morph attribute data cannot\nbe changed. You will have to call `dispose()?, and create a new geometry instance.\n\n@type {Object}\n/\n\t\tthis.morphAttributes = {};\n\n\t\t/**\nUsed to control the morph target behavior; when set to `true`, the morph\ntarget data is treated as relative offsets, rather than as absolute\npositions/normals.\n\n@type {boolean}\n@default false\n/\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\nSplit the geometry into groups, each of which will be rendered in a\nseparate draw call. This allows an array of materials to be used with the geometry.\n\nUse `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\nEvery vertex and index must belong to exactly one group — groups must not share vertices or\nindices, and must not leave vertices or indices unused.\n\n@type {Array<Object>}\n/\n\t\tthis.groups = [];\n\n\t\t/**\nBounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\n@type {?Box3}\n@default null\n/\n\t\tthis.boundingBox = null;\n\n\t\t/**\nBounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\n@type {?Sphere}\n@default null\n/\n\t\tthis.boundingSphere = null;\n\n\t\t/**\nDetermines the part of the geometry to render. This should not be set directly,\ninstead use `setDrawRange()`.\n\n@type {{start:number,count:number}}\n/\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\nAn object that can be used to store custom data about the geometry.\nIt should not hold references to functions as these will not be cloned.\n\n@type {Object}\n/\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\nReturns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/",
    "identifiers": [
      "getindex",
      "index"
    ],
    "start_line": 195,
    "end_line": 199,
    "text": "getIndex() {\n\n\t\treturn this.index;\n\n\t}"
  },
  {
    "id": "b7c147c0b6694ad0e413f65ebf8dd85d6b3afcf3",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/BufferGeometry.js",
    "kind": "method",
    "name": "constructor",
    "signature": "constructor()",
    "docstring": "A representation of mesh, line, or point geometry. Includes vertex\npositions, face indices, normals, colors, UVs, and custom attributes\nwithin buffers, reducing the cost of passing all this data to the GPU.\n\n```js\nconst geometry = new THREE.BufferGeometry();\n// create a simple square shape. We duplicate the top left and bottom right\n// vertices because each vertex needs to appear once per triangle.\nconst vertices = new Float32Array( [\n\t-1.0, -1.0,  1.0, // v0\n\t 1.0, -1.0,  1.0, // v1\n\t 1.0,  1.0,  1.0, // v2\n\n\t 1.0,  1.0,  1.0, // v3\n\t-1.0,  1.0,  1.0, // v4\n\t-1.0, -1.0,  1.0  // v5\n] );\n// itemSize = 3 because there are 3 values (components) per vertex\ngeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\nconst material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );\nconst mesh = new THREE.Mesh( geometry, material );\n```\n\n@augments EventDispatcher\n/\nclass BufferGeometry extends EventDispatcher {\n\n\t/**\nConstructs a new geometry.\n/",
    "identifiers": [
      "_id",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "constructor",
      "count",
      "defineproperty",
      "drawrange",
      "generateuuid",
      "groups",
      "index",
      "indirect",
      "infinity",
      "isbuffergeometry",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "object",
      "start",
      "type",
      "userdata",
      "uuid",
      "value"
    ],
    "start_line": 53,
    "end_line": 188,
    "text": "constructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\n\t\t * The ID of the geometry.\n\t\t *\n\t\t * @name BufferGeometry#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The UUID of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\n\t\t * Allows for vertices to be re-used across multiple triangles; this is\n\t\t * called using \"indexed triangles\". Each triangle is associated with the\n\t\t * indices of three vertices. This attribute therefore stores the index of\n\t\t * each vertex for each triangular face. If this attribute is not set, the\n\t\t * renderer assumes that each three contiguous positions represent a single triangle.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.index = null;\n\n\t\t/**\n\t\t * A (storage) buffer attribute which was generated with a compute shader and\n\t\t * now defines indirect draw calls.\n\t\t *\n\t\t * Can only be used with {@link WebGPURenderer} and a WebGPU backend.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.indirect = null;\n\n\t\t/**\n\t\t * This dictionary has as id the name of the attribute to be set and as value\n\t\t * the buffer attribute to set it to. Rather than accessing this property directly,\n\t\t * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\t\t *\n\t\t * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n\t\t */\n\t\tthis.attributes = {};\n\n\t\t/**\n\t\t * This dictionary holds the morph targets of the geometry.\n\t\t *\n\t\t * Note: Once the geometry has been rendered, the morph attribute data cannot\n\t\t * be changed. You will have to call `dispose()?, and create a new geometry instance.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.morphAttributes = {};\n\n\t\t/**\n\t\t * Used to control the morph target behavior; when set to `true`, the morph\n\t\t * target data is treated as relative offsets, rather than as absolute\n\t\t * positions/normals.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\n\t\t * Split the geometry into groups, each of which will be rendered in a\n\t\t * separate draw call. This allows an array of materials to be used with the geometry.\n\t\t *\n\t\t * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\t\t *\n\t\t * Every vertex and index must belong to exactly one group — groups must not share vertices or\n\t\t * indices, and must not leave vertices or indices unused.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.groups = [];\n\n\t\t/**\n\t\t * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Determines the part of the geometry to render. This should not be set directly,\n\t\t * instead use `setDrawRange()`.\n\t\t *\n\t\t * @type {{start:number,count:number}}\n\t\t */\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the geometry.\n\t\t * It should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t}"
  },
  {
    "id": "bdc28ad316fb40b77a23d243d69c3f29f3874669",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/finetune.py",
    "kind": "function",
    "name": "main",
    "signature": "main()",
    "docstring": "",
    "identifiers": [
      "chatcompletion",
      "create",
      "e",
      "encoding",
      "error",
      "exception",
      "extract_python_code",
      "f",
      "full_prompt",
      "main",
      "max_completion_tokens",
      "messages",
      "model",
      "new_main_py_code",
      "open",
      "openai",
      "openaierror",
      "original_eval_py",
      "original_main_py",
      "print",
      "prompt_text",
      "read_file",
      "replace",
      "response",
      "response_text",
      "write"
    ],
    "start_line": 23,
    "end_line": 62,
    "text": "def main():\n    try:\n  \n        prompt_text = read_file(\"prompt/code/finetune.md\")\n        \n       \n        original_main_py = read_file(\"iter_code/paper/code_generate/main.py\")\n        original_eval_py = read_file(\"code_generate/evaluation/evaluate.py\")\n        \n \n        full_prompt = prompt_text.replace(\"{template}\", original_main_py).replace(\"{evaluate}\", original_eval_py)\n        print(full_prompt)\n        \n\n        response = openai.ChatCompletion.create(\n            model=\"o1-mini\",  # or \"gpt-4o\" if that's your custom model name\n            messages=[{\"role\": \"user\", \"content\": full_prompt}],\n            max_completion_tokens=8000\n        )\n        \n        print(response)\n     \n        response_text = response[\"choices\"][0][\"message\"][\"content\"]\n        #print(response_text)\n        \n       \n        new_main_py_code = extract_python_code(response_text)\n        \n       \n        if new_main_py_code:\n            with open(\"iter_code/paper/code_generate/main.py\", \"w\", encoding=\"utf-8\") as f:\n                f.write(new_main_py_code)\n            print(\"main.py has been updated successfully.\")\n        else:\n            print(\"No Python code block found in the model's response. main.py was not changed.\")\n    \n    except openai.error.OpenAIError as e:\n        print(f\"Error calling OpenAI API: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
  },
  {
    "id": "9dde1525c18ac9c540e58119e9a0e5a946164841",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/finetune.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(text: str)",
    "docstring": "Find the first fenced Python code block in the text.\n    Example fence:\n    python ...\n    \n    Returns the code (string) inside the fence or an empty string if not found.",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "pattern",
      "re",
      "search",
      "str",
      "strip",
      "text"
    ],
    "start_line": 9,
    "end_line": 21,
    "text": "def extract_python_code(text: str) -> str:\n    \"\"\"\n    Find the first fenced Python code block in the text.\n    Example fence:\n    python ...\n    \n    Returns the code (string) inside the fence or an empty string if not found.\n    \"\"\"\n    pattern = r\"```python(.*?)```\"\n    match = re.search(pattern, text, re.DOTALL)\n    if match:\n        return match.group(1).strip()\n    return \"\""
  },
  {
    "id": "0dbbcb701baf4b29619d7bdecec8dab9fa4b6c8b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/finetune.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(path: str)",
    "docstring": "Utility function to read text content from a file.",
    "identifiers": [
      "encoding",
      "f",
      "open",
      "path",
      "read",
      "read_file",
      "str"
    ],
    "start_line": 4,
    "end_line": 7,
    "text": "def read_file(path: str) -> str:\n    \"\"\"Utility function to read text content from a file.\"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return f.read()"
  },
  {
    "id": "ce2f15a5e9a9d146be50c85c66b53f206515d12f",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/merge.py",
    "kind": "function",
    "name": "extract_and_merge_json",
    "signature": "extract_and_merge_json(directory, output_file)",
    "docstring": "Extracts JSON content from all .py files in the directory and merges into one JSON file\n    with file names as keys and their corresponding JSON content as values.",
    "identifiers": [
      "_",
      "append",
      "directory",
      "dump",
      "encoding",
      "endswith",
      "ensure_ascii",
      "extract_and_merge_json",
      "extract_json_from_file",
      "extracted_json",
      "file_name",
      "file_order",
      "file_path",
      "files",
      "files_with_order",
      "group",
      "indent",
      "int",
      "join",
      "json",
      "key",
      "match",
      "merged_json",
      "open",
      "os",
      "out_file",
      "output_file",
      "path",
      "print",
      "re",
      "root",
      "search",
      "sort",
      "walk",
      "x"
    ],
    "start_line": 44,
    "end_line": 75,
    "text": "def extract_and_merge_json(directory, output_file):\n    \"\"\"\n    Extracts JSON content from all .py files in the directory and merges into one JSON file\n    with file names as keys and their corresponding JSON content as values.\n    \"\"\"\n    merged_json = {}\n    files_with_order = []\n\n    for root, _, files in os.walk(directory):\n        for file_name in files:\n            \n            if file_name.endswith((\".py\", \".json\")):\n      \n                match = re.search(r'_(\\d+)\\.(py|json)$', file_name)\n                if match:\n                    file_order = int(match.group(1))  \n                    file_path = os.path.join(root, file_name)  \n                    files_with_order.append((file_order, file_path, file_name))\n\n    # Sort files based on their numeric order\n    files_with_order.sort(key=lambda x: x[0])\n\n    # Process files in sorted order\n    for _, file_path, file_name in files_with_order:\n        extracted_json = extract_json_from_file(file_path)\n        # Add the extracted content to the merged JSON dictionary\n        merged_json[file_name] = extracted_json\n\n    # Write the merged JSON to the output file\n    with open(output_file, 'w', encoding='utf-8') as out_file:\n        json.dump(merged_json, out_file, indent=4, ensure_ascii=False)\n    print(f\"Merged JSON written to {output_file}\")"
  },
  {
    "id": "e691198a583fd569c91c2dafbdbb0c7a7044b8a0",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/merge.py",
    "kind": "function",
    "name": "extract_json_from_file",
    "signature": "extract_json_from_file(file_path)",
    "docstring": "Extracts JSON content enclosed in ```json ... ``` from a given file.",
    "identifiers": [
      "append",
      "clean_json_content",
      "cleaned_json",
      "content",
      "current_json",
      "e",
      "encoding",
      "extract_json_from_file",
      "file",
      "file_path",
      "inside_json",
      "json",
      "json_blocks",
      "json_data",
      "jsondecodeerror",
      "line",
      "loads",
      "open",
      "print",
      "read",
      "splitlines",
      "strip"
    ],
    "start_line": 15,
    "end_line": 42,
    "text": "def extract_json_from_file(file_path):\n    \"\"\"\n    Extracts JSON content enclosed in ```json ... ``` from a given file.\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n    \n    json_blocks = []\n    inside_json = False\n    current_json = \"\"\n    \n    for line in content.splitlines():\n        if line.strip() == \"```json\":\n            inside_json = True\n            current_json = \"\"\n        elif line.strip() == \"```\" and inside_json:\n            inside_json = False\n            try:\n                # Clean JSON content before parsing\n                cleaned_json = clean_json_content(current_json)\n                json_data = json.loads(cleaned_json)\n                json_blocks.append(json_data)\n            except json.JSONDecodeError as e:\n                print(f\"Error decoding JSON in file {file_path}: {e}. Skipping this block.\")\n        elif inside_json:\n            current_json += line + \"\\n\"\n    \n    return json_blocks"
  },
  {
    "id": "f04959015d2b0e2f027dcd8f845e99326da2da38",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/merge.py",
    "kind": "function",
    "name": "clean_json_content",
    "signature": "clean_json_content(content)",
    "docstring": "Cleans the JSON content by removing comments (e.g., lines starting with //).",
    "identifiers": [
      "clean_json_content",
      "cleaned_content",
      "content",
      "dotall",
      "flags",
      "re",
      "sub"
    ],
    "start_line": 5,
    "end_line": 13,
    "text": "def clean_json_content(content):\n    \"\"\"\n    Cleans the JSON content by removing comments (e.g., lines starting with //).\n    \"\"\"\n    # Remove single-line comments (e.g., // comment)\n    cleaned_content = re.sub(r'//.*', '', content)\n    # Optionally remove multi-line comments (e.g., /* comment */)\n    cleaned_content = re.sub(r'/\\*.*?\\*/', '', cleaned_content, flags=re.DOTALL)\n    return cleaned_content"
  }
]