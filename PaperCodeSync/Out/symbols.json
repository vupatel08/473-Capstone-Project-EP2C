[
  {
    "id": "4cdb452f3b12d10108af8abf0564bcf3e3a3a978",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/alignment.py",
    "kind": "function",
    "name": "remove_comments_and_docstrings",
    "signature": "remove_comments_and_docstrings(source)",
    "docstring": "",
    "identifiers": [
      "append",
      "bytesio",
      "comment",
      "decode",
      "encode",
      "indent",
      "io",
      "io_obj",
      "new_source",
      "newline",
      "output_tokens",
      "prev_toktype",
      "readline",
      "remove_comments_and_docstrings",
      "source",
      "startswith",
      "string",
      "token",
      "token_string",
      "token_type",
      "tokenerror",
      "tokenize",
      "type",
      "untokenize"
    ],
    "start_line": 62,
    "end_line": 84,
    "text": "def remove_comments_and_docstrings(source):\n\n    io_obj = io.BytesIO(source.encode('utf-8'))\n    output_tokens = []\n    prev_toktype = tokenize.INDENT\n    try:\n        for token in tokenize.tokenize(io_obj.readline):\n            token_type = token.type\n            token_string = token.string\n        \n            if token_type == tokenize.COMMENT:\n                continue\n            \n            if token_type == tokenize.STRING and prev_toktype in (tokenize.INDENT, tokenize.NEWLINE):\n                if token_string.startswith('\"\"\"') or token_string.startswith(\"'''\"):\n                    continue\n            output_tokens.append(token)\n            prev_toktype = token_type\n    except tokenize.TokenError:\n       \n        return source\n    new_source = tokenize.untokenize(output_tokens).decode('utf-8')\n    return new_source"
  },
  {
    "id": "d50b26d2ed31a10bc6c25f8aed51a7a10b2c6d8f",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/alignment.py",
    "kind": "function",
    "name": "construct_prompt",
    "signature": "construct_prompt(paper_content, files_content)",
    "docstring": "",
    "identifiers": [
      "construct_prompt",
      "content",
      "file_contents_str",
      "files_content",
      "items",
      "paper_content",
      "path",
      "prompt"
    ],
    "start_line": 40,
    "end_line": 60,
    "text": "def construct_prompt(paper_content, files_content):\n\n\n    file_contents_str = \"\"\n    for path, content in files_content.items():\n        file_contents_str += f\"file_path: {path}\\ncontent:\\n{content}\\n{'-'*60}\\n\"\n\n    prompt = f\"\"\"Please evaluate whether the following file content correctly implements the requirements outlined in the paper. In particular, carefully assess the internal implementation concerning model design, loss function design, and model updating. If any issues are found in the file content, please return the corrected complete code for the corresponding file. The output must follow the format: filename + file content, and it should be enclosed within a Python code block.\n\nPaper content:\n{'='*80}\n{paper_content}\n{'='*80}\n\nFile content:\n{'='*80}\n{file_contents_str}\n{'='*80}\n\"\"\"\n\n    return prompt"
  },
  {
    "id": "07ec93aac6a6452cac37f46813ca08cf83358e18",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/alignment.py",
    "kind": "function",
    "name": "read_markdown_file",
    "signature": "read_markdown_file(md_file_path)",
    "docstring": "",
    "identifiers": [
      "e",
      "encoding",
      "exception",
      "f",
      "md_file_path",
      "open",
      "print",
      "read",
      "read_markdown_file"
    ],
    "start_line": 29,
    "end_line": 36,
    "text": "def read_markdown_file(md_file_path):\n\n    try:\n        with open(md_file_path, 'r', encoding='utf-8') as f:\n            return f.read()\n    except Exception as e:\n        print(f\"read file {md_file_path} error: {e}\")\n        return \"\""
  },
  {
    "id": "4f72c0dcb959ef707c313f65a9ff389d2d697270",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/alignment.py",
    "kind": "function",
    "name": "read_files_from_dir",
    "signature": "read_files_from_dir(root_dir, extensions=(\".py\", \".json\"))",
    "docstring": "",
    "identifiers": [
      "_",
      "content",
      "dirpath",
      "e",
      "encoding",
      "endswith",
      "exception",
      "extensions",
      "f",
      "file_contents",
      "filename",
      "filenames",
      "full_path",
      "join",
      "open",
      "os",
      "path",
      "print",
      "read",
      "read_files_from_dir",
      "root_dir",
      "walk"
    ],
    "start_line": 14,
    "end_line": 27,
    "text": "def read_files_from_dir(root_dir, extensions=(\".py\", \".json\")):\n\n    file_contents = {}\n    for dirpath, _, filenames in os.walk(root_dir):\n        for filename in filenames:\n            if filename.endswith(extensions):\n                full_path = os.path.join(dirpath, filename)\n                try:\n                    with open(full_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                    file_contents[full_path] = content\n                except Exception as e:\n                    print(f\"read file {full_path} error: {e}\")\n    return file_contents"
  },
  {
    "id": "9130e334260923e4b748046bf6040815038ff276",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/alignment.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 9,
    "end_line": 12,
    "text": "def write_file(file_path, content):\n\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "bc49eb6f6a8d01e8331507933692364cf685360f",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_fix.py",
    "kind": "function",
    "name": "run_fix_script",
    "signature": "run_fix_script(code_str, script_path=\"test.py\")",
    "docstring": "",
    "identifiers": [
      "code_str",
      "communicate",
      "cwd",
      "pipe",
      "popen",
      "process",
      "returncode",
      "run_fix_script",
      "script_path",
      "stderr",
      "stdout",
      "subprocess",
      "text",
      "write_file"
    ],
    "start_line": 41,
    "end_line": 52,
    "text": "def run_fix_script(code_str, script_path=\"test.py\"):\n    # Function to write fix code to a temporary file and run it via subprocess\n    write_file(script_path, code_str)\n    process = subprocess.Popen(\n        [\"python\", script_path],\n        cwd=\"iter_code/paper/code_generate\",\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n    stdout, stderr = process.communicate()\n    return stdout, stderr, process.returncode"
  },
  {
    "id": "63a1a94cca1d54834fff64fd143bc93758578a8f",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_fix.py",
    "kind": "function",
    "name": "run_main_py",
    "signature": "run_main_py(target_directory)",
    "docstring": "",
    "identifiers": [
      "communicate",
      "copy",
      "cwd",
      "env",
      "environ",
      "os",
      "pipe",
      "popen",
      "process",
      "returncode",
      "run_main_py",
      "stderr",
      "stdout",
      "subprocess",
      "target_directory",
      "text"
    ],
    "start_line": 26,
    "end_line": 39,
    "text": "def run_main_py(target_directory):\n    # Function to run main.py in the specified directory using CUDA device 2\n    env = os.environ.copy()\n    env[\"CUDA_VISIBLE_DEVICES\"] = \"2\"\n    process = subprocess.Popen(\n        [\"python\", \"main.py\"],\n        cwd=target_directory,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n        env=env\n    )\n    stdout, stderr = process.communicate()\n    return stdout, stderr, process.returncode"
  },
  {
    "id": "3f7644170f81722651481caab77fe779850d3009",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_fix.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(response)",
    "docstring": "",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "re",
      "response",
      "search",
      "strip"
    ],
    "start_line": 18,
    "end_line": 24,
    "text": "def extract_python_code(response):\n    # Function to extract Python code between ```python``` code blocks\n    match = re.search(r'```python\\n(.*?)\\n```', response, re.DOTALL)\n    if match:\n        return match.group(1).strip()\n    else:\n        return None"
  },
  {
    "id": "cd4467681f0ba413f073b1af3808b1f6e6390157",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_fix.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 13,
    "end_line": 16,
    "text": "def write_file(file_path, content):\n    # Function to write content to a file with UTF-8 encoding\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "3b18bc80919c9be2d7f03a3d7f410fcf5dc51d08",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_fix.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(file_path)",
    "docstring": "",
    "identifiers": [
      "encoding",
      "file",
      "file_path",
      "open",
      "read",
      "read_file"
    ],
    "start_line": 8,
    "end_line": 11,
    "text": "def read_file(file_path):\n    # Function to read file content with UTF-8 encoding\n    with open(file_path, 'r', encoding='utf-8') as file:\n        return file.read()"
  },
  {
    "id": "ff7673506af26d1b4affc4b9f4088507e72c0d84",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "process_files",
    "signature": "process_files(merged_json_path, paper_path, prompt_file_path, output_directory)",
    "docstring": "",
    "identifiers": [
      "copy",
      "dict",
      "dumps",
      "encoding",
      "ensure_ascii",
      "extract_python_code",
      "f",
      "file_design_content",
      "generate_prompt",
      "indent",
      "isinstance",
      "items",
      "join",
      "json",
      "key",
      "load",
      "merged_data",
      "merged_data_copy",
      "merged_data_str",
      "merged_json_path",
      "open",
      "os",
      "output_directory",
      "output_file_path",
      "paper_content",
      "paper_path",
      "path",
      "print",
      "process_files",
      "prompt",
      "prompt_file_path",
      "prompt_template",
      "python_code",
      "python_file_content",
      "read_file",
      "response",
      "save_generated_code",
      "send_to_model",
      "write_file"
    ],
    "start_line": 58,
    "end_line": 106,
    "text": "def process_files(merged_json_path, paper_path, prompt_file_path, output_directory):\n\n    paper_content = read_file(paper_path)\n    \n\n    prompt_template = read_file(prompt_file_path)\n\n\n    with open(merged_json_path, 'r', encoding='utf-8') as f:\n        merged_data = json.load(f)\n\n    merged_data_copy = merged_data.copy()\n\n\n    for key, file_design_content in merged_data.items():\n\n        if not isinstance(file_design_content, dict) or \"file_name\" not in file_design_content:\n            print(f\"Skipping {key} because 'file_name' field not found or content is not a dict.\")\n            continue\n\n\n        output_file_path = os.path.join(output_directory, file_design_content[\"file_name\"])\n\n\n        python_file_content = json.dumps(file_design_content, ensure_ascii=False, indent=4)\n        merged_data_str = json.dumps(merged_data_copy, ensure_ascii=False, indent=4)\n        \n        prompt = generate_prompt(prompt_template, paper_content, python_file_content, merged_data_str)\n        \n        write_file(\"/home/lzj/code_for_run/paper2code/test.py\", prompt)\n\n        \n        response = send_to_model(prompt)\n\n        if response:\n           \n            python_code = extract_python_code(response)\n\n            if python_code:\n                \n                save_generated_code(output_file_path, python_code)\n                print(f\"Response for {key} saved to {output_file_path}\")\n                \n                \n                merged_data_copy[key] = python_code\n            else:\n                print(f\"No Python code found in the response for {key}\")\n        else:\n            print(f\"Error processing {key}\")"
  },
  {
    "id": "0e7855652d86d67eb006b2b6a9925b227daa6fef",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(response)",
    "docstring": "",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "re",
      "response",
      "search",
      "strip"
    ],
    "start_line": 50,
    "end_line": 56,
    "text": "def extract_python_code(response):\n\n    match = re.search(r'```python\\n(.*?)\\n```', response, re.DOTALL)\n    if match:\n        return match.group(1).strip()  \n    else:\n        return None"
  },
  {
    "id": "7061204ca3b62680ec4beb06b53ee379618f2e97",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "generate_prompt",
    "signature": "generate_prompt(prompt_template, paper_content, python_file_content, whole_design)",
    "docstring": "",
    "identifiers": [
      "generate_prompt",
      "paper_content",
      "prompt",
      "prompt_template",
      "python_file_content",
      "replace",
      "whole_design"
    ],
    "start_line": 43,
    "end_line": 48,
    "text": "def generate_prompt(prompt_template, paper_content, python_file_content, whole_design):\n\n    prompt = prompt_template.replace(\"{paper_content}\", paper_content)\n    prompt = prompt.replace(\"{python_file_content}\", python_file_content)\n    prompt = prompt.replace(\"{whole_design}\", whole_design)\n    return prompt"
  },
  {
    "id": "9392e08d2612a31bed9ec6e9470ff79496c17b0c",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "send_to_model",
    "signature": "send_to_model(prompt)",
    "docstring": "",
    "identifiers": [
      "chatcompletion",
      "completion_tokens",
      "create",
      "e",
      "exception",
      "max_completion_tokens",
      "messages",
      "model",
      "openai",
      "print",
      "prompt",
      "prompt_tokens",
      "response",
      "send_to_model",
      "total_tokens",
      "usage_info"
    ],
    "start_line": 20,
    "end_line": 41,
    "text": "def send_to_model(prompt):\n    messages = [\n        {\"role\": \"user\", \"content\": \"You are a Python code implementation expert.\\n\\n\" + prompt}\n    ]\n    \n    try:\n\n        response = openai.ChatCompletion.create(\n            model=\"o1-mini\",  # 或 \"o1-mini\"\n            messages=messages,\n            max_completion_tokens=8000\n        )\n \n        usage_info = response['usage']\n        prompt_tokens = usage_info['prompt_tokens']\n        completion_tokens = usage_info['completion_tokens']\n        total_tokens = usage_info['total_tokens']\n        print(f\"Prompt tokens: {prompt_tokens}, Completion tokens: {completion_tokens}, Total tokens: {total_tokens}\")\n        return response['choices'][0]['message']['content']\n    except Exception as e:\n        print(f\"Error calling OpenAI API: {e}\")\n        return None"
  },
  {
    "id": "b9b429059a83a2737e79304ff17db321af916414",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "save_generated_code",
    "signature": "save_generated_code(file_path, code)",
    "docstring": "",
    "identifiers": [
      "code",
      "dirname",
      "encoding",
      "exist_ok",
      "file",
      "file_path",
      "makedirs",
      "open",
      "os",
      "path",
      "save_generated_code",
      "write"
    ],
    "start_line": 14,
    "end_line": 18,
    "text": "def save_generated_code(file_path, code):\n\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(code)"
  },
  {
    "id": "5522599ecb2c2fa91b775a92cb9658220cddc5d5",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "write_file",
    "signature": "write_file(file_path, content)",
    "docstring": "",
    "identifiers": [
      "content",
      "encoding",
      "file",
      "file_path",
      "open",
      "write",
      "write_file"
    ],
    "start_line": 10,
    "end_line": 12,
    "text": "def write_file(file_path, content):\n    with open(file_path, 'w', encoding='utf-8') as file:\n        file.write(content)"
  },
  {
    "id": "00c649c923092e36f57e3980c57bd8adbaa74c72",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/code_generate.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(file_path)",
    "docstring": "",
    "identifiers": [
      "encoding",
      "file",
      "file_path",
      "open",
      "read",
      "read_file"
    ],
    "start_line": 6,
    "end_line": 8,
    "text": "def read_file(file_path):\n    with open(file_path, 'r', encoding='utf-8') as file:\n        return file.read()"
  },
  {
    "id": "93f6314092807d8a074dfb752e29b3a27fe4ce07",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/finetune.py",
    "kind": "function",
    "name": "main",
    "signature": "main()",
    "docstring": "",
    "identifiers": [
      "chatcompletion",
      "create",
      "e",
      "encoding",
      "error",
      "exception",
      "extract_python_code",
      "f",
      "full_prompt",
      "main",
      "max_completion_tokens",
      "messages",
      "model",
      "new_main_py_code",
      "open",
      "openai",
      "openaierror",
      "original_eval_py",
      "original_main_py",
      "print",
      "prompt_text",
      "read_file",
      "replace",
      "response",
      "response_text",
      "write"
    ],
    "start_line": 23,
    "end_line": 62,
    "text": "def main():\n    try:\n  \n        prompt_text = read_file(\"prompt/code/finetune.md\")\n        \n       \n        original_main_py = read_file(\"iter_code/paper/code_generate/main.py\")\n        original_eval_py = read_file(\"code_generate/evaluation/evaluate.py\")\n        \n \n        full_prompt = prompt_text.replace(\"{template}\", original_main_py).replace(\"{evaluate}\", original_eval_py)\n        print(full_prompt)\n        \n\n        response = openai.ChatCompletion.create(\n            model=\"o1-mini\",  # or \"gpt-4o\" if that's your custom model name\n            messages=[{\"role\": \"user\", \"content\": full_prompt}],\n            max_completion_tokens=8000\n        )\n        \n        print(response)\n     \n        response_text = response[\"choices\"][0][\"message\"][\"content\"]\n        #print(response_text)\n        \n       \n        new_main_py_code = extract_python_code(response_text)\n        \n       \n        if new_main_py_code:\n            with open(\"iter_code/paper/code_generate/main.py\", \"w\", encoding=\"utf-8\") as f:\n                f.write(new_main_py_code)\n            print(\"main.py has been updated successfully.\")\n        else:\n            print(\"No Python code block found in the model's response. main.py was not changed.\")\n    \n    except openai.error.OpenAIError as e:\n        print(f\"Error calling OpenAI API: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
  },
  {
    "id": "4915f25a0f4bb2f6a90954b17c94c35f11fdfac8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/finetune.py",
    "kind": "function",
    "name": "extract_python_code",
    "signature": "extract_python_code(text: str)",
    "docstring": "Find the first fenced Python code block in the text.\n    Example fence:\n    python ...\n    \n    Returns the code (string) inside the fence or an empty string if not found.",
    "identifiers": [
      "dotall",
      "extract_python_code",
      "group",
      "match",
      "pattern",
      "re",
      "search",
      "str",
      "strip",
      "text"
    ],
    "start_line": 9,
    "end_line": 21,
    "text": "def extract_python_code(text: str) -> str:\n    \"\"\"\n    Find the first fenced Python code block in the text.\n    Example fence:\n    python ...\n    \n    Returns the code (string) inside the fence or an empty string if not found.\n    \"\"\"\n    pattern = r\"```python(.*?)```\"\n    match = re.search(pattern, text, re.DOTALL)\n    if match:\n        return match.group(1).strip()\n    return \"\""
  },
  {
    "id": "fc45293044c02eb6667df782c940ded9897e2cec",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/finetune.py",
    "kind": "function",
    "name": "read_file",
    "signature": "read_file(path: str)",
    "docstring": "Utility function to read text content from a file.",
    "identifiers": [
      "encoding",
      "f",
      "open",
      "path",
      "read",
      "read_file",
      "str"
    ],
    "start_line": 4,
    "end_line": 7,
    "text": "def read_file(path: str) -> str:\n    \"\"\"Utility function to read text content from a file.\"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return f.read()"
  },
  {
    "id": "c279c00419f8a1b3a0c802ce6ea8ae5ef1141cba",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/merge.py",
    "kind": "function",
    "name": "extract_and_merge_json",
    "signature": "extract_and_merge_json(directory, output_file)",
    "docstring": "Extracts JSON content from all .py files in the directory and merges into one JSON file\n    with file names as keys and their corresponding JSON content as values.",
    "identifiers": [
      "_",
      "append",
      "directory",
      "dump",
      "encoding",
      "endswith",
      "ensure_ascii",
      "extract_and_merge_json",
      "extract_json_from_file",
      "extracted_json",
      "file_name",
      "file_order",
      "file_path",
      "files",
      "files_with_order",
      "group",
      "indent",
      "int",
      "join",
      "json",
      "key",
      "match",
      "merged_json",
      "open",
      "os",
      "out_file",
      "output_file",
      "path",
      "print",
      "re",
      "root",
      "search",
      "sort",
      "walk",
      "x"
    ],
    "start_line": 44,
    "end_line": 75,
    "text": "def extract_and_merge_json(directory, output_file):\n    \"\"\"\n    Extracts JSON content from all .py files in the directory and merges into one JSON file\n    with file names as keys and their corresponding JSON content as values.\n    \"\"\"\n    merged_json = {}\n    files_with_order = []\n\n    for root, _, files in os.walk(directory):\n        for file_name in files:\n            \n            if file_name.endswith((\".py\", \".json\")):\n      \n                match = re.search(r'_(\\d+)\\.(py|json)$', file_name)\n                if match:\n                    file_order = int(match.group(1))  \n                    file_path = os.path.join(root, file_name)  \n                    files_with_order.append((file_order, file_path, file_name))\n\n    # Sort files based on their numeric order\n    files_with_order.sort(key=lambda x: x[0])\n\n    # Process files in sorted order\n    for _, file_path, file_name in files_with_order:\n        extracted_json = extract_json_from_file(file_path)\n        # Add the extracted content to the merged JSON dictionary\n        merged_json[file_name] = extracted_json\n\n    # Write the merged JSON to the output file\n    with open(output_file, 'w', encoding='utf-8') as out_file:\n        json.dump(merged_json, out_file, indent=4, ensure_ascii=False)\n    print(f\"Merged JSON written to {output_file}\")"
  },
  {
    "id": "5402b1bb01cd0ca12fbc60e34600fc94e950c59a",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/merge.py",
    "kind": "function",
    "name": "extract_json_from_file",
    "signature": "extract_json_from_file(file_path)",
    "docstring": "Extracts JSON content enclosed in ```json ... ``` from a given file.",
    "identifiers": [
      "append",
      "clean_json_content",
      "cleaned_json",
      "content",
      "current_json",
      "e",
      "encoding",
      "extract_json_from_file",
      "file",
      "file_path",
      "inside_json",
      "json",
      "json_blocks",
      "json_data",
      "jsondecodeerror",
      "line",
      "loads",
      "open",
      "print",
      "read",
      "splitlines",
      "strip"
    ],
    "start_line": 15,
    "end_line": 42,
    "text": "def extract_json_from_file(file_path):\n    \"\"\"\n    Extracts JSON content enclosed in ```json ... ``` from a given file.\n    \"\"\"\n    with open(file_path, 'r', encoding='utf-8') as file:\n        content = file.read()\n    \n    json_blocks = []\n    inside_json = False\n    current_json = \"\"\n    \n    for line in content.splitlines():\n        if line.strip() == \"```json\":\n            inside_json = True\n            current_json = \"\"\n        elif line.strip() == \"```\" and inside_json:\n            inside_json = False\n            try:\n                # Clean JSON content before parsing\n                cleaned_json = clean_json_content(current_json)\n                json_data = json.loads(cleaned_json)\n                json_blocks.append(json_data)\n            except json.JSONDecodeError as e:\n                print(f\"Error decoding JSON in file {file_path}: {e}. Skipping this block.\")\n        elif inside_json:\n            current_json += line + \"\\n\"\n    \n    return json_blocks"
  },
  {
    "id": "038d90b2db7ab5699d84c2f26dc32a13829b0b82",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Python/merge.py",
    "kind": "function",
    "name": "clean_json_content",
    "signature": "clean_json_content(content)",
    "docstring": "Cleans the JSON content by removing comments (e.g., lines starting with //).",
    "identifiers": [
      "clean_json_content",
      "cleaned_content",
      "content",
      "dotall",
      "flags",
      "re",
      "sub"
    ],
    "start_line": 5,
    "end_line": 13,
    "text": "def clean_json_content(content):\n    \"\"\"\n    Cleans the JSON content by removing comments (e.g., lines starting with //).\n    \"\"\"\n    # Remove single-line comments (e.g., // comment)\n    cleaned_content = re.sub(r'//.*', '', content)\n    # Optionally remove multi-line comments (e.g., /* comment */)\n    cleaned_content = re.sub(r'/\\*.*?\\*/', '', cleaned_content, flags=re.DOTALL)\n    return cleaned_content"
  },
  {
    "id": "90101ade7e22a813e3ec75926999edf84671c6c3",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/CPP/llama-chat.cpp",
    "kind": "function",
    "name": "len",
    "signature": "llama_chat_builtin_templates(const char ** output, size_t len)",
    "docstring": "template not supported",
    "identifiers": [
      "advance",
      "begin",
      "c_str",
      "first",
      "i",
      "it",
      "len",
      "llama_chat_builtin_templates",
      "llm_chat_templates",
      "min",
      "output",
      "size"
    ],
    "start_line": 826,
    "end_line": 833,
    "text": "int32_t llama_chat_builtin_templates(const char ** output, size_t len) {\n    auto it = LLM_CHAT_TEMPLATES.begin();\n    for (size_t i = 0; i < std::min(len, LLM_CHAT_TEMPLATES.size()); i++) {\n        output[i] = it->first.c_str();\n        std::advance(it, 1);\n    }\n    return (int32_t) LLM_CHAT_TEMPLATES.size();\n}"
  },
  {
    "id": "85e4eb48776c5717f523d628744ffc6758ee2c42",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/CPP/llama-chat.cpp",
    "kind": "function",
    "name": "add_ass",
    "signature": "llm_chat_apply_template(\n    llm_chat_template tmpl,\n    const std::vector<const llama_chat_message *> & chat,\n    std::string & dest, bool add_ass)",
    "docstring": "Simple version of \"llama_apply_chat_template\" that only works with strings\nThis function uses heuristic checks to determine commonly used template. It is not a jinja parser.",
    "identifiers": [
      "add_ass",
      "add_bos_inside_history",
      "begin",
      "bos",
      "chat",
      "content",
      "dest",
      "empty",
      "end",
      "front",
      "has_system",
      "i",
      "is_inside_turn",
      "leading_space",
      "llama_chat_message",
      "llm_chat_apply_template",
      "llm_chat_template",
      "llm_chat_template_bailing",
      "llm_chat_template_bailing2",
      "llm_chat_template_bailing_think",
      "llm_chat_template_chatglm_3",
      "llm_chat_template_chatglm_4",
      "llm_chat_template_chatml",
      "llm_chat_template_command_r",
      "llm_chat_template_deepseek",
      "llm_chat_template_deepseek_2",
      "llm_chat_template_deepseek_3",
      "llm_chat_template_dots1",
      "llm_chat_template_exaone_3",
      "llm_chat_template_exaone_4",
      "llm_chat_template_falcon_3",
      "llm_chat_template_gemma",
      "llm_chat_template_gigachat",
      "llm_chat_template_glmedge",
      "llm_chat_template_granite",
      "llm_chat_template_grok_2",
      "llm_chat_template_hunyuan_dense",
      "llm_chat_template_hunyuan_moe",
      "llm_chat_template_kimi_k2",
      "llm_chat_template_llama4",
      "llm_chat_template_llama_2",
      "llm_chat_template_llama_2_sys",
      "llm_chat_template_llama_2_sys_bos",
      "llm_chat_template_llama_2_sys_strip",
      "llm_chat_template_llama_3",
      "llm_chat_template_megrez",
      "llm_chat_template_minicpm",
      "llm_chat_template_mistral_v1",
      "llm_chat_template_mistral_v3",
      "llm_chat_template_mistral_v3_tekken",
      "llm_chat_template_mistral_v7",
      "llm_chat_template_mistral_v7_tekken",
      "llm_chat_template_monarch",
      "llm_chat_template_openai_moe",
      "llm_chat_template_openchat",
      "llm_chat_template_orion",
      "llm_chat_template_phi_3",
      "llm_chat_template_phi_4",
      "llm_chat_template_rwkv_world",
      "llm_chat_template_seed_oss",
      "llm_chat_template_smolvlm",
      "llm_chat_template_vicuna",
      "llm_chat_template_vicuna_orca",
      "llm_chat_template_yandex",
      "llm_chat_template_zephyr",
      "lu8",
      "message",
      "role",
      "size",
      "ss",
      "str",
      "string",
      "stringstream",
      "strip_message",
      "support_system_message",
      "system_prompt",
      "tmpl",
      "toupper",
      "trailing_space",
      "transform",
      "trim",
      "trim_assistant_message",
      "vector"
    ],
    "start_line": 222,
    "end_line": 822,
    "text": "int32_t llm_chat_apply_template(\n    llm_chat_template tmpl,\n    const std::vector<const llama_chat_message *> & chat,\n    std::string & dest, bool add_ass) {\n    // Taken from the research: https://github.com/ggerganov/llama.cpp/issues/5527\n    std::stringstream ss;\n    if (tmpl == LLM_CHAT_TEMPLATE_CHATML) {\n        // chatml template\n        for (auto message : chat) {\n            ss << \"<|im_start|>\" << message->role << \"\\n\" << message->content << \"<|im_end|>\\n\";\n        }\n        if (add_ass) {\n            ss << \"<|im_start|>assistant\\n\";\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7 || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7_TEKKEN) {\n        // Official mistral 'v7' template\n        // See: https://huggingface.co/mistralai/Mistral-Large-Instruct-2411#basic-instruct-template-v7\n        //      https://huggingface.co/mistralai/Mistral-Small-3.1-24B-Instruct-2503#basic-instruct-template-v7-tekken\n        const char * trailing_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V7 ? \" \" : \"\";\n        for (auto message : chat) {\n            std::string role(message->role);\n            std::string content(message->content);\n            if (role == \"system\") {\n                ss << \"[SYSTEM_PROMPT]\" << trailing_space << content << \"[/SYSTEM_PROMPT]\";\n            } else if (role == \"user\") {\n                ss << \"[INST]\" << trailing_space << content << \"[/INST]\";\n            } else {\n                ss << trailing_space << content << \"</s>\";\n            }\n        }\n    } else if (tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V1\n            || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3\n            || tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN) {\n        // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/chat_templates.md\n        // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/templates.md\n        std::string leading_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V1 ? \" \" : \"\";\n        std::string trailing_space = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN ? \"\" : \" \";\n        bool trim_assistant_message = tmpl == LLM_CHAT_TEMPLATE_MISTRAL_V3;\n        bool is_inside_turn = false;\n        for (auto message : chat) {\n            if (!is_inside_turn) {\n                ss << leading_space << \"[INST]\" << trailing_space;\n                is_inside_turn = true;\n            }\n            std::string role(message->role);\n            std::string content(message->content);\n            if (role == \"system\") {\n                ss << content << \"\\n\\n\";\n            } else if (role == \"user\") {\n                ss << content << leading_space << \"[/INST]\";\n            } else {\n                ss << trailing_space << (trim_assistant_message ? trim(content) : content) << \"</s>\";\n                is_inside_turn = false;\n            }\n        }\n    } else if (\n            tmpl == LLM_CHAT_TEMPLATE_LLAMA_2\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS\n            || tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP) {\n        // llama2 template and its variants\n        // [variant] support system message\n        // See: https://huggingface.co/blog/llama2#how-to-prompt-llama-2\n        bool support_system_message = tmpl != LLM_CHAT_TEMPLATE_LLAMA_2;\n        // [variant] add BOS inside history\n        bool add_bos_inside_history = tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS;\n        // [variant] trim spaces from the input message\n        bool strip_message = tmpl == LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP;\n        // construct the prompt\n        bool is_inside_turn = true; // skip BOS at the beginning\n        ss << \"[INST] \";\n        for (auto message : chat) {\n            std::string content = strip_message ? trim(message->content) : message->content;\n            std::string role(message->role);\n            if (!is_inside_turn) {\n                is_inside_turn = true;\n                ss << (add_bos_inside_history ? \"<s>[INST] \" : \"[INST] \");\n        "
  },
  {
    "id": "5c0362c5970fac35b941fe125c5b529167e65ea0",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/CPP/llama-chat.cpp",
    "kind": "function",
    "name": "tmpl",
    "signature": "llm_chat_detect_template(const std::string & tmpl)",
    "docstring": "",
    "identifiers": [
      "add_bos_inside_history",
      "find",
      "haystack",
      "llm_chat_detect_template",
      "llm_chat_template",
      "llm_chat_template_bailing",
      "llm_chat_template_bailing2",
      "llm_chat_template_bailing_think",
      "llm_chat_template_chatglm_3",
      "llm_chat_template_chatglm_4",
      "llm_chat_template_chatml",
      "llm_chat_template_command_r",
      "llm_chat_template_deepseek",
      "llm_chat_template_deepseek_2",
      "llm_chat_template_deepseek_3",
      "llm_chat_template_dots1",
      "llm_chat_template_exaone_3",
      "llm_chat_template_exaone_4",
      "llm_chat_template_falcon_3",
      "llm_chat_template_from_str",
      "llm_chat_template_gemma",
      "llm_chat_template_gigachat",
      "llm_chat_template_glmedge",
      "llm_chat_template_granite",
      "llm_chat_template_grok_2",
      "llm_chat_template_hunyuan_dense",
      "llm_chat_template_hunyuan_moe",
      "llm_chat_template_kimi_k2",
      "llm_chat_template_llama4",
      "llm_chat_template_llama_2",
      "llm_chat_template_llama_2_sys",
      "llm_chat_template_llama_2_sys_bos",
      "llm_chat_template_llama_2_sys_strip",
      "llm_chat_template_llama_3",
      "llm_chat_template_megrez",
      "llm_chat_template_minicpm",
      "llm_chat_template_mistral_v1",
      "llm_chat_template_mistral_v3",
      "llm_chat_template_mistral_v3_tekken",
      "llm_chat_template_mistral_v7",
      "llm_chat_template_monarch",
      "llm_chat_template_openai_moe",
      "llm_chat_template_openchat",
      "llm_chat_template_orion",
      "llm_chat_template_phi_3",
      "llm_chat_template_phi_4",
      "llm_chat_template_rwkv_world",
      "llm_chat_template_seed_oss",
      "llm_chat_template_smolvlm",
      "llm_chat_template_unknown",
      "llm_chat_template_vicuna",
      "llm_chat_template_vicuna_orca",
      "llm_chat_template_yandex",
      "llm_chat_template_zephyr",
      "lu8",
      "npos",
      "out_of_range",
      "string",
      "strip_message",
      "support_system_message",
      "tmpl",
      "tmpl_contains"
    ],
    "start_line": 82,
    "end_line": 218,
    "text": "llm_chat_template llm_chat_detect_template(const std::string & tmpl) {\n    try {\n        return llm_chat_template_from_str(tmpl);\n    } catch (const std::out_of_range &) {\n        // ignore\n    }\n\n    auto tmpl_contains = [&tmpl](const char * haystack) -> bool {\n        return tmpl.find(haystack) != std::string::npos;\n    };\n    if (tmpl_contains(\"<|im_start|>\")) {\n        return tmpl_contains(\"<|im_sep|>\")\n            ? LLM_CHAT_TEMPLATE_PHI_4\n            : tmpl_contains(\"<end_of_utterance>\")\n                ? LLM_CHAT_TEMPLATE_SMOLVLM // SmolVLM uses <|im_start|> as BOS, but it is NOT chatml\n                : LLM_CHAT_TEMPLATE_CHATML;\n    } else if (tmpl.find(\"mistral\") == 0 || tmpl_contains(\"[INST]\")) {\n        if (tmpl_contains(\"[SYSTEM_PROMPT]\")) {\n            return LLM_CHAT_TEMPLATE_MISTRAL_V7;\n        } else if (\n            // catches official 'v1' template\n            tmpl_contains(\"' [INST] ' + system_message\")\n            // catches official 'v3' and 'v3-tekken' templates\n            || tmpl_contains(\"[AVAILABLE_TOOLS]\")\n        ) {\n            // Official mistral 'v1', 'v3' and 'v3-tekken' templates\n            // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/chat_templates.md\n            // See: https://github.com/mistralai/cookbook/blob/main/concept-deep-dive/tokenization/templates.md\n            if (tmpl_contains(\" [INST]\")) {\n                return LLM_CHAT_TEMPLATE_MISTRAL_V1;\n            } else if (tmpl_contains(\"\\\"[INST]\\\"\")) {\n                return LLM_CHAT_TEMPLATE_MISTRAL_V3_TEKKEN;\n            }\n            return LLM_CHAT_TEMPLATE_MISTRAL_V3;\n        } else {\n            // llama2 template and its variants\n            // [variant] support system message\n            // See: https://huggingface.co/blog/llama2#how-to-prompt-llama-2\n            bool support_system_message = tmpl_contains(\"<<SYS>>\");\n            bool add_bos_inside_history = tmpl_contains(\"bos_token + '[INST]\");\n            bool strip_message = tmpl_contains(\"content.strip()\");\n            if (strip_message) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS_STRIP;\n            } else if (add_bos_inside_history) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS_BOS;\n            } else if (support_system_message) {\n                return LLM_CHAT_TEMPLATE_LLAMA_2_SYS;\n            } else {\n                return LLM_CHAT_TEMPLATE_LLAMA_2;\n            }\n        }\n    } else if (tmpl_contains(\"<|assistant|>\") && tmpl_contains(\"<|end|>\")) {\n        return LLM_CHAT_TEMPLATE_PHI_3;\n    } else if (tmpl_contains(\"[gMASK]<sop>\")) {\n        return LLM_CHAT_TEMPLATE_CHATGLM_4;\n    } else if (tmpl_contains(\"<|assistant|>\") && tmpl_contains(\"<|user|>\")) {\n        return tmpl_contains(\"</s>\") ? LLM_CHAT_TEMPLATE_FALCON_3 : LLM_CHAT_TEMPLATE_GLMEDGE;\n    } else if (tmpl_contains(\"<|{{ item['role'] }}|>\") && tmpl_contains(\"<|begin_of_image|>\")) {\n        return LLM_CHAT_TEMPLATE_GLMEDGE;\n    } else if (tmpl_contains(\"<|user|>\") && tmpl_contains(\"<|endoftext|>\")) {\n        return LLM_CHAT_TEMPLATE_ZEPHYR;\n    } else if (tmpl_contains(\"bos_token + message['role']\")) {\n        return LLM_CHAT_TEMPLATE_MONARCH;\n    } else if (tmpl_contains(\"<start_of_turn>\")) {\n        return LLM_CHAT_TEMPLATE_GEMMA;\n    } else if (tmpl_contains(\"'\\\\n\\\\nAssistant: ' + eos_token\")) {\n        // OrionStarAI/Orion-14B-Chat\n        return LLM_CHAT_TEMPLATE_ORION;\n    } else if (tmpl_contains(\"GPT4 Correct \")) {\n        // openchat/openchat-3.5-0106\n        return LLM_CHAT_TEMPLATE_OPENCHAT;\n    } else if (tmpl_contains(\"USER: \") && tmpl_contains(\"ASSISTANT: \")) {\n        // eachadea/vicuna-13b-1.1 (and Orca variant)\n        if (tmpl_contains(\"SYSTEM: \")) {\n            return LLM_CHAT_TEMPLATE_VICUNA_ORCA;\n        }\n        return LLM_CHAT_TEMPLATE_VICUNA;\n    } else if (tmpl_contains(\"### Instruction:\") && tmpl_contains(\"<|EOT|>\")) {\n        // deepseek-ai/deepseek-coder-33b-instruct\n        return LLM_CHAT_TEMPLATE_DEEPSEEK;\n    } els"
  },
  {
    "id": "1a4bcdee172983eb63b10a9ef51170ffc2b5d68a",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/CPP/llama-chat.cpp",
    "kind": "function",
    "name": "name",
    "signature": "llm_chat_template_from_str(const std::string & name)",
    "docstring": "",
    "identifiers": [
      "at",
      "llm_chat_template",
      "llm_chat_template_from_str",
      "llm_chat_templates",
      "name",
      "string"
    ],
    "start_line": 78,
    "end_line": 80,
    "text": "llm_chat_template llm_chat_template_from_str(const std::string & name) {\n    return LLM_CHAT_TEMPLATES.at(name);\n}"
  },
  {
    "id": "1dc9f24e8baa46ecd2bbe6e2c27b3f48283e62d4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/CPP/llama-chat.cpp",
    "kind": "function",
    "name": "str",
    "signature": "trim(const std::string & str)",
    "docstring": "trim whitespace from the beginning and end of a string",
    "identifiers": [
      "end",
      "isspace",
      "size",
      "start",
      "static_cast",
      "str",
      "string",
      "substr",
      "trim"
    ],
    "start_line": 16,
    "end_line": 26,
    "text": "static std::string trim(const std::string & str) {\n    size_t start = 0;\n    size_t end = str.size();\n    while (start < end && isspace(static_cast<unsigned char>(str[start]))) {\n        start += 1;\n    }\n    while (end > start && isspace(static_cast<unsigned char>(str[end - 1]))) {\n        end -= 1;\n    }\n    return str.substr(start, end - start);\n}"
  },
  {
    "id": "da64145b5dd3581403e4ba2e9b7cbe712cba50dc",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "class",
    "name": "HierholzerEulerianPath",
    "signature": "HierholzerEulerianPath",
    "docstring": "",
    "identifiers": [
      "abs",
      "add",
      "addedge",
      "adjacencylist",
      "allnonzerodegreeverticesweaklyconnected",
      "arraydeque",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "computedegrees",
      "currentindex",
      "deque",
      "determinestartnode",
      "diff",
      "edgecount",
      "endcount",
      "findeulerianpath",
      "from",
      "get",
      "getedges",
      "getnumnodes",
      "graph",
      "hierholzereulerianpath",
      "i",
      "idx",
      "indegree",
      "integer",
      "isempty",
      "length",
      "list",
      "math",
      "n",
      "node",
      "numnodes",
      "outdegree",
      "path",
      "peek",
      "pollfirst",
      "pop",
      "preferredstart",
      "push",
      "reverse",
      "rotated",
      "rotateeuleriancircuitifneeded",
      "singletonlist",
      "size",
      "stack",
      "startcount",
      "startnode",
      "tempadj",
      "to",
      "u",
      "v",
      "visited",
      "x",
      "y"
    ],
    "start_line": 38,
    "end_line": 303,
    "text": "public class HierholzerEulerianPath {\n\n    /**\n     * Simple directed graph represented by adjacency lists.\n     */\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\n         * Constructs a graph with a given number of vertices.\n         *\n         * @param numNodes number of vertices\n         */\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\n         * Adds a directed edge from vertex {@code from} to vertex {@code to}.\n         *\n         * @param from source vertex\n         * @param to   destination vertex\n         */\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\n         * Returns a list of outgoing edges from the given vertex.\n         *\n         * @param node vertex index\n         * @return list of destination vertices\n         */\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\n         * Returns the number of vertices in the graph.\n         *\n         * @return number of vertices\n         */\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }\n\n    private final Graph graph;\n\n    /**\n     * Creates a Hierholzer solver for the given graph.\n     *\n     * @param graph directed graph\n     */\n    public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }\n\n    /**\n     * Finds an Eulerian Path or Circuit using Hierholzer’s Algorithm.\n     *\n     * @return list of vertices representing the Eulerian Path/Circuit,\n     *         or an empty list if none exists\n     */\n    public List<Integer> findEulerianPath() {\n        int n = graph.getNumNodes();\n\n        // empty graph -> no path\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        int[] inDegree = new int[n];\n        int[] outDegree = new int[n];\n        int edgeCount = computeDegrees(inDegree, outDegree);\n\n        // no edges -> single vertex response requested by tests: [0]\n        if (edgeCount == 0) {\n            return Collections.singletonList(0);\n        }\n\n        int startNode = determineStartNode(inDegree, outDegree);\n        if (startNode == -1) {\n            return new ArrayList<>();\n        }\n\n        if (!allNonZeroDegreeVerticesWeaklyConnected(startNode, n, outDegree, inDegree)) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> path = buildHierholzerPath(startNode, n);\n        if (path.size() != edgeCount + 1) {\n            return new ArrayList<>();\n        }\n\n        return rotateEulerianCircuitIfNeeded(path, outDegree, inDegree);\n    }\n\n    private int computeDegrees(int[] inDegree, int[] outDegree) {\n        int edgeCount = 0;\n        for (int u = 0; u < graph.getNumNodes(); u++) {\n            for (int v : graph.getEdges(u)) {\n                outDegree[u]++;\n                inDegree[v]++;\n                edgeCount++;\n            }\n        }\n        return edgeCount;\n    }\n\n    private int determineStartNode(int[] inDegree, int[] outDegree) {\n        int n = graph.getNumNodes();\n        int startNode = -1;\n        int startCount = 0;\n        int endCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startNode = i;\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            } else if (Math.abs(diff) > 1) {\n                return -1;\n            }\n        }\n\n        if (!((startCount == 1 && endCount == 1) || (startCount == 0 && endCount == 0))) {\n            return -1;\n        }\n\n        if (startNode == -1) {\n            for (int i = 0; i < n; i++) {\n                if (outDegree[i] > 0) {\n                    startNode = i;\n                    break;\n  "
  },
  {
    "id": "51e4c229f71a038e074b4f10e020f12f473b7aa8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "allNonZeroDegreeVerticesWeaklyConnected",
    "signature": "allNonZeroDegreeVerticesWeaklyConnected(int startNode, int n, int[] outDegree, int[] inDegree)",
    "docstring": "Checks weak connectivity (undirected) among vertices that have non-zero degree.\n\n@param startNode node to start DFS from (must be a vertex with non-zero degree)\n@param n number of vertices\n@param outDegree out-degree array\n@param inDegree in-degree array\n@return true if all vertices having non-zero degree belong to a single weak component\n/",
    "identifiers": [
      "allnonzerodegreeverticesweaklyconnected",
      "arraydeque",
      "deque",
      "getedges",
      "graph",
      "i",
      "indegree",
      "integer",
      "isempty",
      "n",
      "outdegree",
      "pop",
      "push",
      "stack",
      "startnode",
      "u",
      "v",
      "visited",
      "x",
      "y"
    ],
    "start_line": 269,
    "end_line": 302,
    "text": "private boolean allNonZeroDegreeVerticesWeaklyConnected(int startNode, int n, int[] outDegree, int[] inDegree) {\n        boolean[] visited = new boolean[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(startNode);\n        visited[startNode] = true;\n\n        while (!stack.isEmpty()) {\n            int u = stack.pop();\n            for (int v : graph.getEdges(u)) {\n                if (!visited[v]) {\n                    visited[v] = true;\n                    stack.push(v);\n                }\n            }\n            for (int x = 0; x < n; x++) {\n                if (!visited[x]) {\n                    for (int y : graph.getEdges(x)) {\n                        if (y == u) {\n                            visited[x] = true;\n                            stack.push(x);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (outDegree[i] + inDegree[i] > 0 && !visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }"
  },
  {
    "id": "8c086d040b9cb375ef56953569c5806a81cdf237",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "rotateEulerianCircuitIfNeeded",
    "signature": "rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree)",
    "docstring": "",
    "identifiers": [
      "add",
      "arraylist",
      "currentindex",
      "diff",
      "endcount",
      "get",
      "i",
      "idx",
      "indegree",
      "integer",
      "isempty",
      "length",
      "list",
      "node",
      "outdegree",
      "path",
      "preferredstart",
      "rotated",
      "rotateeuleriancircuitifneeded",
      "startcount"
    ],
    "start_line": 207,
    "end_line": 258,
    "text": "private List<Integer> rotateEulerianCircuitIfNeeded(List<Integer> path, int[] outDegree, int[] inDegree) {\n        int startCount = 0;\n        int endCount = 0;\n        for (int i = 0; i < outDegree.length; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            }\n        }\n\n        if (startCount == 0 && endCount == 0 && !path.isEmpty()) {\n            int preferredStart = -1;\n            for (int i = 0; i < outDegree.length; i++) {\n                if (outDegree[i] > 0) {\n                    preferredStart = i;\n                    break;\n                }\n            }\n\n            if (preferredStart != -1 && path.get(0) != preferredStart) {\n                int idx = 0;\n                for (Integer node : path) { // replaced indexed loop\n                    if (node == preferredStart) {\n                        break;\n                    }\n                    idx++;\n                }\n\n                if (idx > 0) {\n                    List<Integer> rotated = new ArrayList<>();\n                    int currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex >= idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    currentIndex = 0;\n                    for (Integer node : path) { // replaced indexed loop\n                        if (currentIndex < idx) {\n                            rotated.add(node);\n                        }\n                        currentIndex++;\n                    }\n                    path = rotated;\n                }\n            }\n        }\n        return path;\n    }"
  },
  {
    "id": "4ececa757d339b5712e4f58cd20319c3cff57a03",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "buildHierholzerPath",
    "signature": "buildHierholzerPath(int startNode, int n)",
    "docstring": "",
    "identifiers": [
      "add",
      "arraydeque",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "deque",
      "get",
      "getedges",
      "graph",
      "i",
      "integer",
      "isempty",
      "list",
      "n",
      "path",
      "peek",
      "pollfirst",
      "pop",
      "push",
      "reverse",
      "stack",
      "startnode",
      "tempadj",
      "u"
    ],
    "start_line": 184,
    "end_line": 205,
    "text": "private List<Integer> buildHierholzerPath(int startNode, int n) {\n        List<Deque<Integer>> tempAdj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tempAdj.add(new ArrayDeque<>(graph.getEdges(i)));\n        }\n\n        Deque<Integer> stack = new ArrayDeque<>();\n        List<Integer> path = new ArrayList<>();\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int u = stack.peek();\n            if (!tempAdj.get(u).isEmpty()) {\n                stack.push(tempAdj.get(u).pollFirst());\n            } else {\n                path.add(stack.pop());\n            }\n        }\n\n        Collections.reverse(path);\n        return path;\n    }"
  },
  {
    "id": "511776b5a39bb1261d6b0363e3c68759ae9e4039",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "determineStartNode",
    "signature": "determineStartNode(int[] inDegree, int[] outDegree)",
    "docstring": "",
    "identifiers": [
      "abs",
      "determinestartnode",
      "diff",
      "endcount",
      "getnumnodes",
      "graph",
      "i",
      "indegree",
      "math",
      "n",
      "outdegree",
      "startcount",
      "startnode"
    ],
    "start_line": 151,
    "end_line": 182,
    "text": "private int determineStartNode(int[] inDegree, int[] outDegree) {\n        int n = graph.getNumNodes();\n        int startNode = -1;\n        int startCount = 0;\n        int endCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            int diff = outDegree[i] - inDegree[i];\n            if (diff == 1) {\n                startNode = i;\n                startCount++;\n            } else if (diff == -1) {\n                endCount++;\n            } else if (Math.abs(diff) > 1) {\n                return -1;\n            }\n        }\n\n        if (!((startCount == 1 && endCount == 1) || (startCount == 0 && endCount == 0))) {\n            return -1;\n        }\n\n        if (startNode == -1) {\n            for (int i = 0; i < n; i++) {\n                if (outDegree[i] > 0) {\n                    startNode = i;\n                    break;\n                }\n            }\n        }\n        return startNode;\n    }"
  },
  {
    "id": "f1b1ab51e17f0042154359db69445c42b61acedc",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "computeDegrees",
    "signature": "computeDegrees(int[] inDegree, int[] outDegree)",
    "docstring": "",
    "identifiers": [
      "computedegrees",
      "edgecount",
      "getedges",
      "getnumnodes",
      "graph",
      "indegree",
      "outdegree",
      "u",
      "v"
    ],
    "start_line": 139,
    "end_line": 149,
    "text": "private int computeDegrees(int[] inDegree, int[] outDegree) {\n        int edgeCount = 0;\n        for (int u = 0; u < graph.getNumNodes(); u++) {\n            for (int v : graph.getEdges(u)) {\n                outDegree[u]++;\n                inDegree[v]++;\n                edgeCount++;\n            }\n        }\n        return edgeCount;\n    }"
  },
  {
    "id": "efff70d115e7c26fbdf93ee8efe80c5f11ba843d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "findEulerianPath",
    "signature": "findEulerianPath()",
    "docstring": "Finds an Eulerian Path or Circuit using Hierholzer’s Algorithm.\n\n@return list of vertices representing the Eulerian Path/Circuit,\n        or an empty list if none exists\n/",
    "identifiers": [
      "allnonzerodegreeverticesweaklyconnected",
      "arraylist",
      "buildhierholzerpath",
      "collections",
      "computedegrees",
      "determinestartnode",
      "edgecount",
      "findeulerianpath",
      "getnumnodes",
      "graph",
      "indegree",
      "integer",
      "list",
      "n",
      "outdegree",
      "path",
      "rotateeuleriancircuitifneeded",
      "singletonlist",
      "size",
      "startnode"
    ],
    "start_line": 105,
    "end_line": 137,
    "text": "public List<Integer> findEulerianPath() {\n        int n = graph.getNumNodes();\n\n        // empty graph -> no path\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        int[] inDegree = new int[n];\n        int[] outDegree = new int[n];\n        int edgeCount = computeDegrees(inDegree, outDegree);\n\n        // no edges -> single vertex response requested by tests: [0]\n        if (edgeCount == 0) {\n            return Collections.singletonList(0);\n        }\n\n        int startNode = determineStartNode(inDegree, outDegree);\n        if (startNode == -1) {\n            return new ArrayList<>();\n        }\n\n        if (!allNonZeroDegreeVerticesWeaklyConnected(startNode, n, outDegree, inDegree)) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> path = buildHierholzerPath(startNode, n);\n        if (path.size() != edgeCount + 1) {\n            return new ArrayList<>();\n        }\n\n        return rotateEulerianCircuitIfNeeded(path, outDegree, inDegree);\n    }"
  },
  {
    "id": "9b8bfff7397a399e6982102a56b8ca0fdf1ab6ac",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "constructor",
    "name": "HierholzerEulerianPath",
    "signature": "HierholzerEulerianPath(Graph graph)",
    "docstring": "Creates a Hierholzer solver for the given graph.\n\n@param graph directed graph\n/",
    "identifiers": [
      "graph",
      "hierholzereulerianpath"
    ],
    "start_line": 95,
    "end_line": 97,
    "text": "public HierholzerEulerianPath(Graph graph) {\n        this.graph = graph;\n    }"
  },
  {
    "id": "4093109c8f1d7d364f6d389f9659ad4c6eedf863",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "class",
    "name": "Graph",
    "signature": "Graph",
    "docstring": "Simple directed graph represented by adjacency lists.\n/",
    "identifiers": [
      "add",
      "addedge",
      "adjacencylist",
      "arraylist",
      "from",
      "get",
      "getedges",
      "getnumnodes",
      "graph",
      "i",
      "integer",
      "list",
      "node",
      "numnodes",
      "size",
      "to"
    ],
    "start_line": 43,
    "end_line": 86,
    "text": "public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\n         * Constructs a graph with a given number of vertices.\n         *\n         * @param numNodes number of vertices\n         */\n        public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }\n\n        /**\n         * Adds a directed edge from vertex {@code from} to vertex {@code to}.\n         *\n         * @param from source vertex\n         * @param to   destination vertex\n         */\n        public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }\n\n        /**\n         * Returns a list of outgoing edges from the given vertex.\n         *\n         * @param node vertex index\n         * @return list of destination vertices\n         */\n        public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }\n\n        /**\n         * Returns the number of vertices in the graph.\n         *\n         * @return number of vertices\n         */\n        public int getNumNodes() {\n            return adjacencyList.size();\n        }\n    }"
  },
  {
    "id": "19996d5f777c39bca33d1323efc8c3e27ebcb57c",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "getNumNodes",
    "signature": "getNumNodes()",
    "docstring": "Returns the number of vertices in the graph.\n\n@return number of vertices\n/",
    "identifiers": [
      "adjacencylist",
      "getnumnodes",
      "size"
    ],
    "start_line": 83,
    "end_line": 85,
    "text": "public int getNumNodes() {\n            return adjacencyList.size();\n        }"
  },
  {
    "id": "abf6a19257e432400385ee49e92b26ad1b3d9740",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "getEdges",
    "signature": "getEdges(int node)",
    "docstring": "Returns a list of outgoing edges from the given vertex.\n\n@param node vertex index\n@return list of destination vertices\n/",
    "identifiers": [
      "adjacencylist",
      "get",
      "getedges",
      "integer",
      "list",
      "node"
    ],
    "start_line": 74,
    "end_line": 76,
    "text": "public List<Integer> getEdges(int node) {\n            return adjacencyList.get(node);\n        }"
  },
  {
    "id": "ad56ee5b59206828dc2641b5919ef741a27ce6b2",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "method",
    "name": "addEdge",
    "signature": "addEdge(int from, int to)",
    "docstring": "Adds a directed edge from vertex {@code from} to vertex {@code to}.\n\n@param from source vertex\n@param to   destination vertex\n/",
    "identifiers": [
      "add",
      "addedge",
      "adjacencylist",
      "from",
      "get",
      "to"
    ],
    "start_line": 64,
    "end_line": 66,
    "text": "public void addEdge(int from, int to) {\n            adjacencyList.get(from).add(to);\n        }"
  },
  {
    "id": "0b1587dae7f539a4ac739a25306a5ec4c04d3b7e",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/Java/HierholzerEulerianPath.java",
    "kind": "constructor",
    "name": "Graph",
    "signature": "Graph(int numNodes)",
    "docstring": "Simple directed graph represented by adjacency lists.\n/\n    public static class Graph {\n        private final List<List<Integer>> adjacencyList;\n\n        /**\nConstructs a graph with a given number of vertices.\n\n@param numNodes number of vertices\n/",
    "identifiers": [
      "add",
      "adjacencylist",
      "arraylist",
      "graph",
      "i",
      "numnodes"
    ],
    "start_line": 51,
    "end_line": 56,
    "text": "public Graph(int numNodes) {\n            adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numNodes; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n        }"
  },
  {
    "id": "823925b78098981c2995fe3db38f1f8607695ecf",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "class",
    "name": "BufferGeometry",
    "signature": "BufferGeometry",
    "docstring": "",
    "identifiers": [
      "_box",
      "_boxmorphtargets",
      "_id",
      "_m1",
      "_obj",
      "_offset",
      "_vector",
      "a",
      "ab",
      "add",
      "addgroup",
      "addscaledvector",
      "addvectors",
      "angle",
      "applymatrix4",
      "applynormalmatrix",
      "applyquaternion",
      "array",
      "array2",
      "arrayneedsuint32",
      "attribute",
      "attributearray",
      "attributes",
      "b",
      "boundingbox",
      "boundingsphere",
      "box3",
      "bufferattribute",
      "buffergeometry",
      "c",
      "call",
      "cb",
      "center",
      "cleargroups",
      "clone",
      "computeboundingbox",
      "computeboundingsphere",
      "computetangents",
      "computevertexnormals",
      "constructor",
      "convertbufferattribute",
      "copy",
      "count",
      "cross",
      "crossvectors",
      "data",
      "defineproperty",
      "deleteattribute",
      "dispatchevent",
      "dispose",
      "distancetosquared",
      "dot",
      "drawrange",
      "error",
      "eventdispatcher",
      "expandbypoint",
      "float32array",
      "float32bufferattribute",
      "frombufferattribute",
      "generateuuid",
      "generator",
      "geometry2",
      "getattribute",
      "getcenter",
      "getindex",
      "getindirect",
      "getnormalmatrix",
      "getx",
      "group",
      "groups",
      "handletriangle",
      "handlevertex",
      "hasattribute",
      "hasmorphattributes",
      "i",
      "il",
      "index",
      "index2",
      "indices",
      "indirect",
      "infinity",
      "isarray",
      "isbuffergeometry",
      "isfinite",
      "isglbufferattribute",
      "isinterleavedbufferattribute",
      "isnan",
      "itemsize",
      "j",
      "jl",
      "json",
      "key",
      "keys",
      "l",
      "length",
      "lookat",
      "makeempty",
      "makerotationfromquaternion",
      "makerotationx",
      "makerotationy",
      "makerotationz",
      "makescale",
      "maketranslation",
      "materialindex",
      "math",
      "matrix",
      "matrix3",
      "max",
      "maxradiussq",
      "metadata",
      "min",
      "morpharray",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "multiplyscalar",
      "n",
      "n2",
      "na",
      "name",
      "nb",
      "nc",
      "needsupdate",
      "negate",
      "newattribute",
      "normal",
      "normalattribute",
      "normalize",
      "normalized",
      "normalizenormals",
      "normalmatrix",
      "normals",
      "object",
      "offset",
      "pa",
      "parameters",
      "parse",
      "pb",
      "pc",
      "point",
      "points",
      "position",
      "positionattribute",
      "prototype",
      "push",
      "q",
      "r",
      "radius",
      "rotatex",
      "rotatey",
      "rotatez",
      "scale",
      "sdir",
      "set",
      "setattribute",
      "setdrawrange",
      "setfrombufferattribute",
      "setfrompoints",
      "setindex",
      "setindirect",
      "setxyz",
      "setxyzw",
      "slice",
      "source",
      "sphere",
      "sqrt",
      "start",
      "stride",
      "stringify",
      "sub",
      "subvectors",
      "t",
      "tan1",
      "tan2",
      "tangent",
      "tangentattribute",
      "tdir",
      "test",
      "tmp",
      "tmp2",
      "tojson",
      "tononindexed",
      "transformdirection",
      "translate",
      "type",
      "uint16bufferattribute",
      "uint32bufferattribute",
      "updatematrix",
      "userdata",
      "uuid",
      "uv",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "v",
      "va",
      "value",
      "vb",
      "vc",
      "vector",
      "vector2",
      "vector3",
      "version",
      "w",
      "warn",
      "x",
      "y",
      "z"
    ],
    "start_line": 48,
    "end_line": 1444,
    "text": "class BufferGeometry extends EventDispatcher {\n\n\t/**\n\t * Constructs a new geometry.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\n\t\t * The ID of the geometry.\n\t\t *\n\t\t * @name BufferGeometry#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The UUID of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\n\t\t * Allows for vertices to be re-used across multiple triangles; this is\n\t\t * called using \"indexed triangles\". Each triangle is associated with the\n\t\t * indices of three vertices. This attribute therefore stores the index of\n\t\t * each vertex for each triangular face. If this attribute is not set, the\n\t\t * renderer assumes that each three contiguous positions represent a single triangle.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.index = null;\n\n\t\t/**\n\t\t * A (storage) buffer attribute which was generated with a compute shader and\n\t\t * now defines indirect draw calls.\n\t\t *\n\t\t * Can only be used with {@link WebGPURenderer} and a WebGPU backend.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.indirect = null;\n\n\t\t/**\n\t\t * This dictionary has as id the name of the attribute to be set and as value\n\t\t * the buffer attribute to set it to. Rather than accessing this property directly,\n\t\t * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\t\t *\n\t\t * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n\t\t */\n\t\tthis.attributes = {};\n\n\t\t/**\n\t\t * This dictionary holds the morph targets of the geometry.\n\t\t *\n\t\t * Note: Once the geometry has been rendered, the morph attribute data cannot\n\t\t * be changed. You will have to call `dispose()?, and create a new geometry instance.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.morphAttributes = {};\n\n\t\t/**\n\t\t * Used to control the morph target behavior; when set to `true`, the morph\n\t\t * target data is treated as relative offsets, rather than as absolute\n\t\t * positions/normals.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\n\t\t * Split the geometry into groups, each of which will be rendered in a\n\t\t * separate draw call. This allows an array of materials to be used with the geometry.\n\t\t *\n\t\t * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\t\t *\n\t\t * Every vertex and index must belong to exactly one group — groups must not share vertices or\n\t\t * indices, and must not leave vertices or indices unused.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.groups = [];\n\n\t\t/**\n\t\t * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Determines the part of the geometry to render. This should not be set directly,\n\t\t * instead use `setDrawRange()`.\n\t\t *\n\t\t * @type {{start:number,count:number}}\n\t\t */\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the geometry.\n\t\t * It should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t}\n\n\t/**\n\t * Returns the index of this geometry.\n\t *\n\t * @return {?BufferAttribute} The index. Returns `null` if no index is defined.\n\t */\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\t/**\n\t * Sets the given index to this geometry.\n\t *\n\t * @param {Array<number>|BufferAttribute} index - The index to set.\n\t * @return {BufferGeometry} A ref"
  },
  {
    "id": "6e406b1b48d9cafb1377d6f963c68a2aa49abf24",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "dispose",
    "signature": "dispose()",
    "docstring": "Frees the GPU-related resources allocated by this instance. Call this\nmethod whenever this instance is no longer used in your app.\n\n@fires BufferGeometry#dispose\n/",
    "identifiers": [
      "dispatchevent",
      "dispose",
      "type"
    ],
    "start_line": 1438,
    "end_line": 1442,
    "text": "dispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}"
  },
  {
    "id": "dfc73960dda0c45684d5bd3e20db6a323a3dbd5d",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "copy",
    "signature": "copy( source )",
    "docstring": "Copies the values of the given geometry to this instance.\n\n@param {BufferGeometry} source - The geometry to copy.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "addgroup",
      "array",
      "attribute",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "clone",
      "copy",
      "count",
      "data",
      "drawrange",
      "group",
      "groups",
      "i",
      "index",
      "l",
      "length",
      "materialindex",
      "morphattribute",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "push",
      "setattribute",
      "setindex",
      "source",
      "start",
      "userdata"
    ],
    "start_line": 1327,
    "end_line": 1430,
    "text": "copy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "8670e70b93cb833b04757667fd3b4477a3ecbbf9",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "clone",
    "signature": "clone()",
    "docstring": "Returns a new geometry with copied values from this instance.\n\n@return {BufferGeometry} A clone of this instance.\n/",
    "identifiers": [
      "clone",
      "constructor",
      "copy"
    ],
    "start_line": 1315,
    "end_line": 1319,
    "text": "clone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}"
  },
  {
    "id": "dd0c5a76397cee718e71d80b63d1f51b65119d91",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "toJSON",
    "signature": "toJSON()",
    "docstring": "Serializes the geometry into JSON.\n\n@return {Object} A JSON object representing the serialized geometry.\n/",
    "identifiers": [
      "array",
      "attribute",
      "attributearray",
      "attributes",
      "boundingsphere",
      "call",
      "constructor",
      "data",
      "generator",
      "groups",
      "hasmorphattributes",
      "i",
      "il",
      "index",
      "json",
      "key",
      "keys",
      "length",
      "metadata",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "object",
      "parameters",
      "parse",
      "prototype",
      "push",
      "slice",
      "stringify",
      "tojson",
      "type",
      "userdata",
      "uuid",
      "version"
    ],
    "start_line": 1200,
    "end_line": 1308,
    "text": "toJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.7,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = boundingSphere.toJSON();\n\n\t\t}\n\n\t\treturn data;\n\n\t}"
  },
  {
    "id": "0ee09f63df630541daab1ddbf673e733b2b425ec",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "toNonIndexed",
    "signature": "toNonIndexed()",
    "docstring": "Return a new non-index version of this indexed geometry. If the geometry\nis already non-indexed, the method is a NOOP.\n\n@return {BufferGeometry} The non-indexed version of this indexed geometry.\n/",
    "identifiers": [
      "addgroup",
      "array",
      "array2",
      "attribute",
      "attributes",
      "bufferattribute",
      "buffergeometry",
      "constructor",
      "convertbufferattribute",
      "count",
      "data",
      "geometry2",
      "group",
      "groups",
      "i",
      "il",
      "index",
      "index2",
      "indices",
      "isinterleavedbufferattribute",
      "itemsize",
      "j",
      "l",
      "length",
      "materialindex",
      "morpharray",
      "morphattribute",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "newattribute",
      "normalized",
      "offset",
      "push",
      "setattribute",
      "start",
      "stride",
      "tononindexed",
      "warn"
    ],
    "start_line": 1093,
    "end_line": 1193,
    "text": "toNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\twarn( 'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}"
  },
  {
    "id": "a5d1d38124c0439f49d7394c69b8b62d8b6572ad",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "function",
    "name": "convertBufferAttribute",
    "signature": "convertBufferAttribute( attribute, indices )",
    "docstring": "",
    "identifiers": [
      "array",
      "array2",
      "attribute",
      "bufferattribute",
      "constructor",
      "convertbufferattribute",
      "data",
      "i",
      "index",
      "index2",
      "indices",
      "isinterleavedbufferattribute",
      "itemsize",
      "j",
      "l",
      "length",
      "normalized",
      "offset",
      "stride"
    ],
    "start_line": 1095,
    "end_line": 1127,
    "text": "function convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}"
  },
  {
    "id": "8f38bdf00eab91ba7eef0b9df3e5b07b88deb964",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "normalizeNormals",
    "signature": "normalizeNormals()",
    "docstring": "Ensures every normal vector in a geometry will have a magnitude of `1`. This will\ncorrect lighting on the geometry surfaces.\n/",
    "identifiers": [
      "_vector",
      "attributes",
      "count",
      "frombufferattribute",
      "i",
      "il",
      "normal",
      "normalize",
      "normalizenormals",
      "normals",
      "setxyz",
      "x",
      "y",
      "z"
    ],
    "start_line": 1071,
    "end_line": 1085,
    "text": "normalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}"
  },
  {
    "id": "ec8420d3d267814b8c43f4550b729feb2a03aeba",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "computeVertexNormals",
    "signature": "computeVertexNormals()",
    "docstring": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets\neach vertex normal to be the average of the face normals of the faces that share that vertex.\nFor non-indexed geometries, vertices are not shared, and the method sets each vertex normal\nto be the same as the face normal.\n/",
    "identifiers": [
      "ab",
      "add",
      "bufferattribute",
      "cb",
      "computevertexnormals",
      "count",
      "cross",
      "float32array",
      "frombufferattribute",
      "getattribute",
      "getx",
      "i",
      "il",
      "index",
      "na",
      "nb",
      "nc",
      "needsupdate",
      "normalattribute",
      "normalizenormals",
      "pa",
      "pb",
      "pc",
      "positionattribute",
      "setattribute",
      "setxyz",
      "subvectors",
      "va",
      "vb",
      "vc",
      "vector3",
      "x",
      "y",
      "z"
    ],
    "start_line": 975,
    "end_line": 1065,
    "text": "computeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}"
  },
  {
    "id": "037f1eddd9cf32e25153927fa420ee4750019173",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "computeTangents",
    "signature": "computeTangents()",
    "docstring": "Calculates and adds a tangent attribute to this geometry.\n\nThe computation is only supported for indexed geometries and if position, normal, and uv attributes\nare defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by\n{@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.\n/",
    "identifiers": [
      "a",
      "add",
      "addscaledvector",
      "attributes",
      "b",
      "bufferattribute",
      "c",
      "computetangents",
      "copy",
      "count",
      "crossvectors",
      "dot",
      "error",
      "float32array",
      "frombufferattribute",
      "getattribute",
      "getx",
      "group",
      "groups",
      "handletriangle",
      "handlevertex",
      "hasattribute",
      "i",
      "il",
      "index",
      "isfinite",
      "j",
      "jl",
      "length",
      "multiplyscalar",
      "n",
      "n2",
      "normal",
      "normalattribute",
      "normalize",
      "position",
      "positionattribute",
      "r",
      "sdir",
      "setattribute",
      "setxyzw",
      "start",
      "sub",
      "t",
      "tan1",
      "tan2",
      "tangentattribute",
      "tdir",
      "test",
      "tmp",
      "tmp2",
      "uv",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "v",
      "va",
      "vb",
      "vc",
      "vector2",
      "vector3",
      "w",
      "x",
      "y",
      "z"
    ],
    "start_line": 810,
    "end_line": 967,
    "text": "computeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\terror( 'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}"
  },
  {
    "id": "77849ef8df0ee2480bb55faddcc7f5c6069e3633",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "function",
    "name": "handleVertex",
    "signature": "handleVertex( v )",
    "docstring": "",
    "identifiers": [
      "copy",
      "crossvectors",
      "dot",
      "frombufferattribute",
      "handlevertex",
      "multiplyscalar",
      "n",
      "n2",
      "normalattribute",
      "normalize",
      "setxyzw",
      "sub",
      "t",
      "tan1",
      "tan2",
      "tangentattribute",
      "test",
      "tmp",
      "tmp2",
      "v",
      "w",
      "x",
      "y",
      "z"
    ],
    "start_line": 928,
    "end_line": 948,
    "text": "function handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}"
  },
  {
    "id": "afe83a377d5f9000e8933eea6ac69024516ae0f3",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "function",
    "name": "handleTriangle",
    "signature": "handleTriangle( a, b, c )",
    "docstring": "",
    "identifiers": [
      "a",
      "add",
      "addscaledvector",
      "b",
      "c",
      "copy",
      "frombufferattribute",
      "handletriangle",
      "isfinite",
      "multiplyscalar",
      "positionattribute",
      "r",
      "sdir",
      "sub",
      "tan1",
      "tan2",
      "tdir",
      "uva",
      "uvattribute",
      "uvb",
      "uvc",
      "va",
      "vb",
      "vc",
      "x",
      "y"
    ],
    "start_line": 860,
    "end_line": 893,
    "text": "function handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}"
  },
  {
    "id": "06f3f4bbe4ad6c5a987fb58fc15a2495e61ed675",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "computeBoundingSphere",
    "signature": "computeBoundingSphere()",
    "docstring": "Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.\nThe engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.\nYou may need to recompute the bounding sphere if the geometry vertices are modified.\n/",
    "identifiers": [
      "_box",
      "_boxmorphtargets",
      "_offset",
      "_vector",
      "add",
      "addvectors",
      "attributes",
      "boundingsphere",
      "center",
      "computeboundingsphere",
      "count",
      "distancetosquared",
      "error",
      "expandbypoint",
      "frombufferattribute",
      "getcenter",
      "i",
      "il",
      "infinity",
      "isglbufferattribute",
      "isnan",
      "j",
      "jl",
      "length",
      "math",
      "max",
      "maxradiussq",
      "min",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "position",
      "radius",
      "set",
      "setfrombufferattribute",
      "sphere",
      "sqrt",
      "vector3"
    ],
    "start_line": 691,
    "end_line": 801,
    "text": "computeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\terror( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}"
  },
  {
    "id": "31dd0a438ff69f616e60191ea02c1b8e906ede76",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "computeBoundingBox",
    "signature": "computeBoundingBox()",
    "docstring": "Computes the bounding box of the geometry, and updates the `boundingBox` member.\nThe bounding box is not computed by the engine; it must be computed by your app.\nYou may need to recompute the bounding box if the geometry vertices are modified.\n/",
    "identifiers": [
      "_box",
      "_vector",
      "addvectors",
      "attributes",
      "boundingbox",
      "box3",
      "computeboundingbox",
      "error",
      "expandbypoint",
      "i",
      "il",
      "infinity",
      "isglbufferattribute",
      "isnan",
      "length",
      "makeempty",
      "max",
      "min",
      "morphattribute",
      "morphattributes",
      "morphattributesposition",
      "morphtargetsrelative",
      "position",
      "set",
      "setfrombufferattribute",
      "vector3",
      "x",
      "y",
      "z"
    ],
    "start_line": 616,
    "end_line": 684,
    "text": "computeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\terror( 'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}"
  },
  {
    "id": "ed1b8d609b8237d7a40e75bc2534411a93507aec",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "setFromPoints",
    "signature": "setFromPoints( points )",
    "docstring": "Defines a geometry by creating a `position` attribute based on the given array of points. The array\ncan hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is\nset to `0`.\n\nIf the method is used with an existing `position` attribute, the vertex data are overwritten with the\ndata from the array. The length of the array must match the vertex count.\n\n@param {Array<Vector2>|Array<Vector3>} points - The points.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "count",
      "float32bufferattribute",
      "getattribute",
      "i",
      "l",
      "length",
      "math",
      "min",
      "needsupdate",
      "point",
      "points",
      "position",
      "positionattribute",
      "push",
      "setattribute",
      "setfrompoints",
      "setxyz",
      "warn",
      "x",
      "y",
      "z"
    ],
    "start_line": 569,
    "end_line": 609,
    "text": "setFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\twarn( 'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "551f004169e976a843b68e3042d340eb76dfdad5",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "center",
    "signature": "center()",
    "docstring": "Center the geometry based on its bounding box.\n\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_offset",
      "boundingbox",
      "center",
      "computeboundingbox",
      "getcenter",
      "negate",
      "translate",
      "x",
      "y",
      "z"
    ],
    "start_line": 546,
    "end_line": 556,
    "text": "center() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "0f2724e2434651bcb05d306798dfe038a2c1d710",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "lookAt",
    "signature": "lookAt( vector )",
    "docstring": "Rotates the geometry to face a point in 3D space. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#lookAt} for typical\nreal-time mesh rotation.\n\n@param {Vector3} vector - The target point.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_obj",
      "applymatrix4",
      "lookat",
      "matrix",
      "updatematrix",
      "vector"
    ],
    "start_line": 529,
    "end_line": 539,
    "text": "lookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "4b207eb7a06694f9956d3afc8e2b7e4cdb7925b6",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "scale",
    "signature": "scale( x, y, z )",
    "docstring": "Scales the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#scale} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x scale.\n@param {number} y - The y scale.\n@param {number} z - The z scale.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "makescale",
      "scale",
      "x",
      "y",
      "z"
    ],
    "start_line": 509,
    "end_line": 519,
    "text": "scale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "a29f22ecde00f1ff5d5f7502bfba55de0ad1d553",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "translate",
    "signature": "translate( x, y, z )",
    "docstring": "Translates the geometry. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#position} for typical\nreal-time mesh rotation.\n\n@param {number} x - The x offset.\n@param {number} y - The y offset.\n@param {number} z - The z offset.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "maketranslation",
      "translate",
      "x",
      "y",
      "z"
    ],
    "start_line": 487,
    "end_line": 497,
    "text": "translate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "9419b827706fec47694da39823b8570db52749af",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "rotateZ",
    "signature": "rotateZ( angle )",
    "docstring": "Rotates the geometry about the Z axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationz",
      "rotatez"
    ],
    "start_line": 465,
    "end_line": 475,
    "text": "rotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "6e6c4e662417fbebb4b54a204c30657a58ecd819",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "rotateY",
    "signature": "rotateY( angle )",
    "docstring": "Rotates the geometry about the Y axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationy",
      "rotatey"
    ],
    "start_line": 445,
    "end_line": 455,
    "text": "rotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "0be94293ca3b76c46b7d60da5d336cd078cf0d4c",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "rotateX",
    "signature": "rotateX( angle )",
    "docstring": "Rotates the geometry about the X axis. This is typically done as a one time\noperation, and not during a loop. Use {@link Object3D#rotation} for typical\nreal-time mesh rotation.\n\n@param {number} angle - The angle in radians.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "angle",
      "applymatrix4",
      "makerotationx",
      "rotatex"
    ],
    "start_line": 425,
    "end_line": 435,
    "text": "rotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "dbdde81011793a78b2526ca03336a2ff502bcdc4",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "applyQuaternion",
    "signature": "applyQuaternion( q )",
    "docstring": "Applies the rotation represented by the Quaternion to the geometry.\n\n@param {Quaternion} q - The Quaternion to apply.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "_m1",
      "applymatrix4",
      "applyquaternion",
      "makerotationfromquaternion",
      "q"
    ],
    "start_line": 407,
    "end_line": 415,
    "text": "applyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "df2234be0e9b192d400601270f6691aa69b7aa57",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "applyMatrix4",
    "signature": "applyMatrix4( matrix )",
    "docstring": "Applies the given 4x4 transformation matrix to the geometry.\n\n@param {Matrix4} matrix - The matrix to apply.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "applymatrix4",
      "applynormalmatrix",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "computeboundingbox",
      "computeboundingsphere",
      "getnormalmatrix",
      "matrix",
      "matrix3",
      "needsupdate",
      "normal",
      "normalmatrix",
      "position",
      "tangent",
      "transformdirection"
    ],
    "start_line": 351,
    "end_line": 399,
    "text": "applyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "ce847a826dd32874d08e6285c27514d6693fd14a",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "setDrawRange",
    "signature": "setDrawRange( start, count )",
    "docstring": "Sets the draw range for this geometry.\n\n@param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.\nFor indexed BufferGeometry, `count` is the number of indices to render.\n/",
    "identifiers": [
      "count",
      "drawrange",
      "setdrawrange",
      "start"
    ],
    "start_line": 338,
    "end_line": 343,
    "text": "setDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}"
  },
  {
    "id": "a7464c593b9758f9d65933a64e2056ca1ad9c514",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "clearGroups",
    "signature": "clearGroups()",
    "docstring": "Clears all groups.\n/",
    "identifiers": [
      "cleargroups",
      "groups"
    ],
    "start_line": 325,
    "end_line": 329,
    "text": "clearGroups() {\n\n\t\tthis.groups = [];\n\n\t}"
  },
  {
    "id": "fa89eac5f52288a256cc0e956d4caedb4f7eba4b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "addGroup",
    "signature": "addGroup( start, count, materialIndex = 0 )",
    "docstring": "Adds a group to this geometry.\n\n@param {number} start - The first element in this draw call. That is the first\nvertex for non-indexed geometry, otherwise the first triangle index.\n@param {number} count - Specifies how many vertices (or indices) are part of this group.\n@param {number} [materialIndex=0] - The material array index to use.\n/",
    "identifiers": [
      "addgroup",
      "count",
      "groups",
      "materialindex",
      "push",
      "start"
    ],
    "start_line": 310,
    "end_line": 320,
    "text": "addGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}"
  },
  {
    "id": "5f34c3b2b7764e73499d8a23887dc5c35d0f4fdf",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "hasAttribute",
    "signature": "hasAttribute( name )",
    "docstring": "Returns `true` if this geometry has an attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {boolean} Whether this geometry has an attribute for the given name or not.\n/",
    "identifiers": [
      "attributes",
      "hasattribute",
      "name"
    ],
    "start_line": 296,
    "end_line": 300,
    "text": "hasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}"
  },
  {
    "id": "99d35fa86496d5082a4e6df6bb2a36f8591448bf",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "deleteAttribute",
    "signature": "deleteAttribute( name )",
    "docstring": "Deletes the attribute for the given name.\n\n@param {string} name - The attribute name to delete.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "attributes",
      "deleteattribute",
      "name"
    ],
    "start_line": 282,
    "end_line": 288,
    "text": "deleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "30cebc138f1dcca842f8e3c8e2d35c7494008c76",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "setAttribute",
    "signature": "setAttribute( name, attribute )",
    "docstring": "Sets the given attribute for the given name.\n\n@param {string} name - The attribute name.\n@param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "attribute",
      "attributes",
      "name",
      "setattribute"
    ],
    "start_line": 268,
    "end_line": 274,
    "text": "setAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "93e830abf4dcbb46ad96a11c06bb78c604f1266b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "getAttribute",
    "signature": "getAttribute( name )",
    "docstring": "Returns the buffer attribute for the given name.\n\n@param {string} name - The attribute name.\n@return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.\nReturns `undefined` if not attribute has been found.\n/",
    "identifiers": [
      "attributes",
      "getattribute",
      "name"
    ],
    "start_line": 255,
    "end_line": 259,
    "text": "getAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}"
  },
  {
    "id": "617e9c1e36f1916e6f7c603971bf066d92a367db",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "getIndirect",
    "signature": "getIndirect()",
    "docstring": "Returns the indirect attribute of this geometry.\n\n@return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.\n/",
    "identifiers": [
      "getindirect",
      "indirect"
    ],
    "start_line": 242,
    "end_line": 246,
    "text": "getIndirect() {\n\n\t\treturn this.indirect;\n\n\t}"
  },
  {
    "id": "0a2b73150270dd59dba350da92e52f5b03de880b",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "setIndirect",
    "signature": "setIndirect( indirect )",
    "docstring": "Sets the given indirect attribute to this geometry.\n\n@param {BufferAttribute} indirect - The attribute holding indirect draw calls.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "indirect",
      "setindirect"
    ],
    "start_line": 229,
    "end_line": 235,
    "text": "setIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "25477d8b806730b9eca05837b788dae621a26545",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "setIndex",
    "signature": "setIndex( index )",
    "docstring": "Sets the given index to this geometry.\n\n@param {Array<number>|BufferAttribute} index - The index to set.\n@return {BufferGeometry} A reference to this instance.\n/",
    "identifiers": [
      "array",
      "arrayneedsuint32",
      "index",
      "isarray",
      "setindex",
      "uint16bufferattribute",
      "uint32bufferattribute"
    ],
    "start_line": 207,
    "end_line": 221,
    "text": "setIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}"
  },
  {
    "id": "411da60f9bc7c700d922a335b65c24b74ad643a8",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "getIndex",
    "signature": "getIndex()",
    "docstring": "Returns the index of this geometry.\n\n@return {?BufferAttribute} The index. Returns `null` if no index is defined.\n/",
    "identifiers": [
      "getindex",
      "index"
    ],
    "start_line": 195,
    "end_line": 199,
    "text": "getIndex() {\n\n\t\treturn this.index;\n\n\t}"
  },
  {
    "id": "8ba710523a72e9c250710eccc1f012e752c0a0da",
    "file": "/home/mehdi/CMSC473/473-Capstone-Project-EP2C/PaperCodeSync/src/example_repo/JS/BufferGeometry.js",
    "kind": "method",
    "name": "constructor",
    "signature": "constructor()",
    "docstring": "Constructs a new geometry.\n/",
    "identifiers": [
      "_id",
      "attributes",
      "boundingbox",
      "boundingsphere",
      "constructor",
      "count",
      "defineproperty",
      "drawrange",
      "generateuuid",
      "groups",
      "index",
      "indirect",
      "infinity",
      "isbuffergeometry",
      "morphattributes",
      "morphtargetsrelative",
      "name",
      "object",
      "start",
      "type",
      "userdata",
      "uuid",
      "value"
    ],
    "start_line": 53,
    "end_line": 188,
    "text": "constructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferGeometry = true;\n\n\t\t/**\n\t\t * The ID of the geometry.\n\t\t *\n\t\t * @name BufferGeometry#id\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\t/**\n\t\t * The UUID of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = generateUUID();\n\n\t\t/**\n\t\t * The name of the geometry.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\t/**\n\t\t * Allows for vertices to be re-used across multiple triangles; this is\n\t\t * called using \"indexed triangles\". Each triangle is associated with the\n\t\t * indices of three vertices. This attribute therefore stores the index of\n\t\t * each vertex for each triangular face. If this attribute is not set, the\n\t\t * renderer assumes that each three contiguous positions represent a single triangle.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.index = null;\n\n\t\t/**\n\t\t * A (storage) buffer attribute which was generated with a compute shader and\n\t\t * now defines indirect draw calls.\n\t\t *\n\t\t * Can only be used with {@link WebGPURenderer} and a WebGPU backend.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.indirect = null;\n\n\t\t/**\n\t\t * This dictionary has as id the name of the attribute to be set and as value\n\t\t * the buffer attribute to set it to. Rather than accessing this property directly,\n\t\t * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.\n\t\t *\n\t\t * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}\n\t\t */\n\t\tthis.attributes = {};\n\n\t\t/**\n\t\t * This dictionary holds the morph targets of the geometry.\n\t\t *\n\t\t * Note: Once the geometry has been rendered, the morph attribute data cannot\n\t\t * be changed. You will have to call `dispose()?, and create a new geometry instance.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.morphAttributes = {};\n\n\t\t/**\n\t\t * Used to control the morph target behavior; when set to `true`, the morph\n\t\t * target data is treated as relative offsets, rather than as absolute\n\t\t * positions/normals.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.morphTargetsRelative = false;\n\n\t\t/**\n\t\t * Split the geometry into groups, each of which will be rendered in a\n\t\t * separate draw call. This allows an array of materials to be used with the geometry.\n\t\t *\n\t\t * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.\n\t\t *\n\t\t * Every vertex and index must belong to exactly one group — groups must not share vertices or\n\t\t * indices, and must not leave vertices or indices unused.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.groups = [];\n\n\t\t/**\n\t\t * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.\n\t\t *\n\t\t * @type {?Box3}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingBox = null;\n\n\t\t/**\n\t\t * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.\n\t\t *\n\t\t * @type {?Sphere}\n\t\t * @default null\n\t\t */\n\t\tthis.boundingSphere = null;\n\n\t\t/**\n\t\t * Determines the part of the geometry to render. This should not be set directly,\n\t\t * instead use `setDrawRange()`.\n\t\t *\n\t\t * @type {{start:number,count:number}}\n\t\t */\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t/**\n\t\t * An object that can be used to store custom data about the geometry.\n\t\t * It should not hold references to functions as these will not be cloned.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.userData = {};\n\n\t}"
  }
]