"""
README Generator
Generates comprehensive README files with paper-code traceability,
missing information alerts, and next-step guidance.
"""

import yaml
from typing import Dict, List, Optional
from datetime import datetime


class READMEGenerator:
    """Generates explainable README files for generated repositories."""
    
    def __init__(self):
        """Initialize the README Generator."""
        pass
    
    def generate_readme(
        self,
        paper_metadata: Dict,
        code_structure: Dict,
        traceability_map: Dict,
        missing_info: List[Dict],
        config_data: Optional[Dict] = None
    ) -> str:
        """
        Generate comprehensive README with paper-code links and explanations.
        
        Args:
            paper_metadata: Paper information (title, authors, url)
            code_structure: Repository structure and files
            traceability_map: Code-to-paper traceability mapping
            planning_artifacts: Planning stage artifacts
            missing_info: List of missing information alerts
            config_data: Configuration data if available
            
        Returns:
            Formatted README content
        """
        readme = self._generate_header(paper_metadata)
        readme += self._generate_overview(paper_metadata)
        readme += self._generate_requirements(code_structure, config_data)
        readme += self._generate_structure(code_structure)
        readme += self._generate_code_to_paper_mapping(traceability_map)
        readme += self._generate_missing_information(missing_info)
        readme += self._generate_getting_started(code_structure, config_data)
        readme += self._generate_next_steps(missing_info)
        readme += self._generate_acknowledgments(paper_metadata)
        
        return readme
    
    def _generate_header(self, paper_metadata: Dict) -> str:
        """Generate README header."""
        title = paper_metadata.get("title", "Implementation")
        authors = paper_metadata.get("authors", ["Unknown"])
        
        header = f"""# {title} - Implementation

> **Generated by EP2C (Explainable Paper-to-Code)**  
> Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## üìÑ Paper Reference

**Paper Title:** {title}

**Authors:** {', '.join(authors) if isinstance(authors, list) else authors}

**Paper Link:** {paper_metadata.get("url", "N/A")}

**Abstract:** {paper_metadata.get("abstract", "N/A")[:300]}...

---

"""
        return header
    
    def _generate_overview(self, paper_metadata: Dict) -> str:
        """Generate overview section."""
        overview = """## üéØ Overview

This repository implements the methods described in the paper with automatic 
traceability links between code components and paper sections. Click on any 
code reference to see which part of the paper it implements.

### Key Features

- ‚úÖ **Full Implementation**: Complete codebase generated from paper
- üîó **Paper-Code Traceability**: Direct links between code and paper sections
- ‚ö†Ô∏è **Missing Information Alerts**: Highlights where paper lacks details
- üìö **Explainable Comments**: Code comments reference paper sections

---
"""
        return overview
    
    def _generate_requirements(self, code_structure: Dict, config_data: Optional[Dict]) -> str:
        """Generate requirements section."""
        requirements = "## üì¶ Requirements\n\n"
        requirements += "### Installation\n\n```bash\n"
        
        # Add requirements from config if available
        if config_data and "required_packages" in config_data:
            requirements += "# Install required packages\n"
            for package in config_data["required_packages"]:
                requirements += f"pip install {package}\n"
        else:
            requirements += "# Install required packages\n"
            requirements += "pip install torch torchvision\n"
            requirements += "pip install numpy pandas\n"
        
        requirements += "```\n\n"
        
        # Python version
        if config_data and "python_version" in config_data:
            requirements += f"**Python Version:** {config_data['python_version']}\n\n"
        
        return requirements
    
    def _generate_structure(self, code_structure: Dict) -> str:
        """Generate repository structure section."""
        structure = """## üìÅ Repository Structure

```
"""
        
        # Add files from code_structure
        if "task_list" in code_structure:
            for file in code_structure["task_list"]:
                structure += f"‚îú‚îÄ‚îÄ {file}\n"
        else:
            structure += "‚îú‚îÄ‚îÄ model.py          # Model architecture\n"
            structure += "‚îú‚îÄ‚îÄ trainer.py        # Training loop\n"
            structure += "‚îú‚îÄ‚îÄ evaluation.py     # Evaluation metrics\n"
            structure += "‚îú‚îÄ‚îÄ dataset_loader.py # Data loading\n"
            structure += "‚îú‚îÄ‚îÄ main.py           # Entry point\n"
            structure += "‚îî‚îÄ‚îÄ config.yaml       # Configuration\n"
        
        structure += """```

---
"""
        return structure
    
    def _generate_code_to_paper_mapping(self, traceability_map: Dict) -> str:
        """Generate code-to-paper traceability mapping table."""
        mapping = """## üîó Code-to-Paper Traceability

This section shows which parts of the paper each code component implements.

| Code Component | Paper Reference | Description |
|---------------|-----------------|-------------|
"""
        
        code_to_paper = traceability_map.get("code_to_paper", {})
        
        if code_to_paper:
            for component, sections in list(code_to_paper.items())[:15]:  # Limit to 15 for readability
                sections_str = ", ".join(sections)
                # Shorten component name for table
                component_short = component.split(":")[-1] if ":" in component else component
                mapping += f"| `{component_short}` | {sections_str} | Implements specification from paper |\n"
        else:
            mapping += "| `model.py` | Section 3.2 | Model architecture |\n"
            mapping += "| `trainer.py` | Section 4.1 | Training procedure |\n"
        
        mapping += "\n**Traceability Coverage:** {:.1f}%\n".format(
            traceability_map.get("coverage_score", 0) * 100
        )
        
        mapping += "\n---\n\n"
        return mapping
    
    def _generate_missing_information(self, missing_info: List[Dict]) -> str:
        """Generate missing information alerts."""
        missing = "## ‚ö†Ô∏è Missing Information & Manual Configuration Required\n\n"
        
        if missing_info:
            missing += "The following information was **not specified in the paper** and requires manual attention:\n\n"
            
            for item in missing_info[:10]:  # Limit to 10 for readability
                severity = item.get("severity", "medium")
                severity_icon = {
                    "high": "üî¥",
                    "medium": "üü°",
                    "low": "üü¢"
                }.get(severity, "‚ö™")
                
                missing += f"{severity_icon} **{item.get('type', 'Unknown')}**: {item.get('description', '')}\n"
                if item.get("current_value"):
                    missing += f"   - Current value: `{item['current_value']}`\n"
                if item.get("suggestion"):
                    missing += f"   - Suggestion: {item['suggestion']}\n"
                missing += "\n"
        else:
            missing += "‚úÖ No critical missing information detected. All key parameters are specified in the paper.\n"
        
        missing += "\n---\n\n"
        return missing
    
    def _generate_getting_started(self, code_structure: Dict, config_data: Optional[Dict]) -> str:
        """Generate getting started section."""
        getting_started = """## üöÄ Getting Started

### Quick Start

```bash
# 1. Install dependencies
pip install -r requirements.txt

# 2. Review configuration
cat config.yaml

# 3. Run the implementation
python main.py
```

### Step-by-Step Workflow

1. **Data Preparation**: 
   - Ensure datasets are downloaded (see `dataset_loader.py`)
   - Verify data paths in `config.yaml`

2. **Configuration Review**:
   - Open `config.yaml` and verify all hyperparameters
   - Pay special attention to ‚ö†Ô∏è marked parameters (see Missing Information section)

3. **Training**:
   ```bash
   python main.py
   ```

4. **Evaluation**:
   ```bash
   python evaluation.py
   ```

---
"""
        return getting_started
    
    def _generate_next_steps(self, missing_info: List[Dict]) -> str:
        """Generate next steps section."""
        next_steps = "## üéØ Next Steps\n\n"
        
        if missing_info:
            next_steps += "### Immediate Actions Required\n\n"
            next_steps += "1. **Review Missing Information**: Check the ‚ö†Ô∏è section above\n"
            next_steps += "2. **Update Configuration**: Modify `config.yaml` with appropriate values\n"
            next_steps += "3. **Verify Dataset**: Ensure your dataset matches the paper specifications\n\n"
        
        next_steps += "### Recommended Workflow\n\n"
        next_steps += "1. ‚úÖ Review paper-code traceability (see mapping table)\n"
        next_steps += "2. ‚úÖ Update missing hyperparameters in `config.yaml`\n"
        next_steps += "3. ‚úÖ Download and verify dataset compatibility\n"
        next_steps += "4. ‚úÖ Run training with default settings\n"
        next_steps += "5. ‚úÖ Compare results with paper benchmarks\n"
        next_steps += "6. ‚úÖ Iterate on hyperparameters if needed\n\n"
        
        next_steps += "---\n\n"
        return next_steps
    
    def _generate_acknowledgments(self, paper_metadata: Dict) -> str:
        """Generate acknowledgments section."""
        acknowledgments = """## üôè Acknowledgments

This implementation was generated by **EP2C (Explainable Paper-to-Code)**, 
a system for automatically generating executable code from academic papers with 
comprehensive explanations and traceability.

**Original Paper:** {title} by {authors}

**Generated:** {datetime}

---
""".format(
            title=paper_metadata.get("title", "Paper"),
            authors=', '.join(paper_metadata.get("authors", ["Authors"])),
            datetime=datetime.now().strftime("%Y-%m-%d")
        )
        
        acknowledgments += "\nGenerated by EP2C | [GitHub](https://github.com/your-org/ep2c)\n"
        
        return acknowledgments


if __name__ == "__main__":
    # Example usage
    generator = READMEGenerator()
    
    paper_metadata = {
        "title": "Attention Is All You Need",
        "authors": ["Vaswani et al."],
        "url": "https://arxiv.org/abs/1706.03762",
        "abstract": "We propose a new simple network architecture..."
    }
    
    code_structure = {
        "task_list": ["model.py", "trainer.py", "evaluation.py"]
    }
    
    traceability_map = {
        "code_to_paper": {
            "model.py:Transformer": ["Section 3.2"],
            "trainer.py:Trainer": ["Section 4.1"]
        },
        "coverage_score": 0.75
    }
    
    missing_info = [
        {"type": "hyperparameter", "description": "learning_rate", "severity": "high"},
        {"type": "dataset", "description": "Dataset split ratio", "severity": "medium"}
    ]
    
    readme = generator.generate_readme(
        paper_metadata,
        code_structure,
        traceability_map,
        missing_info
    )
    
    print(readme)

